<!--

      functionality.xml            specht package documentation
                                                                Dmitriy Traytel

         Copyright (C) 2010, Dmitriy Traytel

This chapter gives examples for the usage of this package.

-->

<Chapter Label="functionality">
<Heading>Specht functionality</Heading>

<Section>
<Heading>Structural design</Heading>
The stucture...
</Section>

<Section>
<Heading>Specht functions</Heading>

<ManSection>
<Meth Name="Specht" Label="for an integer" Arg="e"/>
<Meth Name="Specht" Label="for two integers" Arg="e, p"/>
<Meth Name="Specht" Label="for to integers and a valuation map"
  Arg="e, p, val"/>
<Meth Name="Specht" Arg="e, p, val, ring"/>
<Returns>object belonging to the filter <Ref Filt="IsHecke"/></Returns>
<Description>
Let <M>R</M> be a field of characteristic <M>0</M>, <M>q</M> a non-zero
element of <M>R</M>, and let <M>e</M> be the smallest positive integer
such that <M>1+q+\ldots+q^{e-1}=0</M>
(we set <M>e=0</M> if no such integer exists). The record returned
by <C>Specht(e)</C> allows calculations in the Grothendieck rings of
the Hecke algebras <M>H</M> of type <E>A</E> which are defined over
<M>R</M> and have parameter <M>q</M>. (The Hecke algebra is described in
Chapter <Q>Iwahori-Hecke algebras</Q>; see also <Q>Hecke</Q>.) Below we
also describe how to consider Hecke algebras defined over fields of
positive characteristic.<P/>

<Ref Oper="Specht"/> returns an object which contains information about the
the family of Hecke algebras determined by <M>R</M> and <M>q</M>.
This object needs to be passed to the most of the &Specht; functions as
argument.<P/>

<Example>
gap&gt; H:=Specht(5);
&lt;Hecke algebra with e = 5&gt;
gap&gt; Display(last);
Specht(e=5, S(), P(), D())
gap&gt; IsZeroCharacteristic(last);
true
</Example>

There is also a method <Ref Oper="Schur"/> for doing calculations with
the <M>q</M>-Schur algebra. See <Ref Oper="DecompositionMatrix"/>,
and <Ref Oper="CrystalDecompositionMatrix"/>.<P/>

This function requires the package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
<!-- TODO -->
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="Schur" Label="for an integer" Arg="e"/>
<Meth Name="Schur" Label="for two integers" Arg="e, p"/>
<Meth Name="Schur" Label="for to integers and a valuation map"
  Arg="e, p, val"/>
<Meth Name="Schur" Arg="e, p, val, ring"/>
<Returns>object belonging to the filter <Ref Filt="IsSchur"/></Returns>
<Description>
This function behaves almost identically to the function
<Ref Oper="Specht"/>, the only difference being that the belonging modules
are printed as <Q>W</Q>, <Q>P</Q>, <Q>F</Q> and that they correspond to the
<M>q</M>-Weyl modules, the projective decomposable modules, and the simple
modules of the <M>q</M>-Schur algebra respectively. Note that our labeling
of these modules is non-standard, following that used by James in
<Cite Key="J"/>. The standard labeling can be obtained from ours by
replacing all partitions by their conjugates.<P/>

Almost all of the functions in &Specht; which accept a Hecke algebra object
<M>H</M> will also accept the object <M>S</M> returned by <Ref Oper="Schur"/>
.<P/>

In the current version of &Specht; the decomposition matrices of <M>q</M>
-Schur algebras are not fully supported. The <Ref Oper=
"InducedDecompositionMatrix"/> function can be applied to these matrices;
however there are no additional routines available for calculating the
columns corresponding to <M>e</M>-singular partitions. The decomposition
matrices for the <M>q</M>-Schur algebras defined over a field of
characteristic <M>0</M> for <M>n\leq 10</M> are in the &Specht; libraries.

<Example>
gap&gt; S:=Schur(2);
&lt;Schur algebra with e = 2&gt;
gap&gt; InducedDecompositionMatrix(DecompositionMatrix(S,3));
# The following projectives are missing from &lt;d&gt;:
#  [ 2, 2 ]
&lt;5x5 decomposition matrix&gt;
gap&gt; Display(last);
4    | 1                   # DecompositionMatrix(S,4) returns the
3,1  | 1 1                 # full decomposition matrix. The point
2^2  | . 1 .               # of this example is to emphasize the
2,1^2| 1 1 . 1             # current limitations of Schur.
1^4  | 1 . . 1 1
</Example>

Note that when <M>S</M> is defined over a field of characteristic zero then
the functions <Ref Oper="MakeFockWeyl"/> and <Ref Oper="MakeFockPIM"/> will
calculate the canonical basis elements (see <Ref Oper="Specht"/>);
currently <C>MakeFockPIM(</C><M>\mu</M><C>)</C> is implemented only for
<M>e</M>-regular partitions.<P/>

See also <Ref Oper="Specht"/>.
This function requires the package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="DecompositionMatrix" Label="for an algebra and an integer"
  Arg="H, n[, Ordering]"/>
<Meth Name="DecompositionMatrix" Arg="H, file[, Ordering]"/>
<Returns> the decomposition matrix <M>D</M> of <M>H(S_n)</M> where <M>H</M>
is a Hecke algebra object returned by the function <Ref Oper="Specht"/>
(or <Ref Oper="Schur"/> ).</Returns>
<Description>
<Ref Oper="DecompositionMatrix"/> first checks whether the required
decomposition matrix exists as a library file (checking first in the current
directory, next in the directory specified by <Ref Var="SpechtDirectory"/>,
and finally in the &Specht; libraries). If the base field
of <M>H</M> has characteristic zero, <Ref Oper="DecompositionMatrix"/>
next looks for <E>crystallized decomposition matrices</E> (see
<Ref Oper="CrystalDecompositionMatrix"/>). If the decomposition matrix
<M>d</M> is not stored in the library <Ref Oper="DecompositionMatrix"/> will
calculate <M>d</M> when <M>H</M> is a Hecke algebra with a
base field of characteristic zero, and will return <C>fail</C> otherwise
(in which case the function <Ref Oper="CalculateDecompositionMatrix"/>
can be used to force &Specht; to try and
calculate this matrix).<P/>

For Hecke algebras defined over fields of characteristic zero, &Specht;
uses the algorithm of <Cite Key="LLT"/> to calculate decomposition matrices
The decomposition matrices for the <M>q</M>-Schur algebras for <M>n\leq10</M>
are contained in the &Specht; library, as are those for the symmetric group
over fields of positive characteristic when <M>n&lt;15</M>.<P/>

Once a decomposition matrix is known, &Specht; keeps an internal copy
of it which is used by the functions <Ref Oper="MakeSpecht"/>,
<Ref Oper="MakePIM"/>, and <Ref Oper="MakeSimple"/>; these
functions also read decomposition matrix files as needed.<P/>

If you set the variable <Ref Var="SpechtDirectory"/>, then &Specht; will also
search for decomposition matrix files in this directory. The files in the
current directory override those in <Ref Var="SpechtDirectory"/> and those in
the &Specht; libraries.<P/>

In the second form of the function, when a <M>filename</M> is supplied,
<Ref Oper="DecompositionMatrix"/> will read the decomposition matrix in the
file <M>filename</M>, and this matrix will become &Specht;'s internal copy of
this matrix.<P/>

By default, the rows and columns of the decomposition matrices are ordered
<Ref Oper="DecompositionMatrix"/> with an ordering function such as
<Ref Oper="LengthLexicographic"/> or <Ref Oper="ReverseDominance"/>. You do
not need to specify the ordering you want every time you call
<Ref Oper="DecompositionMatrix"/>; &Specht; will keep the same
ordering until you change it again. This ordering can also be set <Q>by
hand</Q> using the operation <Ref Oper="SetOrdering"/>

<Example>
gap&gt; DecompositionMatrix(Specht(3),6,LengthLexicographic);
&lt;11x7 decomposition matrix&gt;
gap&gt; Display(last);
6      | 1
5,1    | 1 1
4,2    | . . 1
3^2    | . 1 . 1
4,1^2  | . 1 . . 1
3,2,1  | 1 1 . 1 1 1
2^3    | 1 . . . . 1
3,1^3  | . . . . 1 1
2^2,1^2| . . . . . . 1
2,1^4  | . . . 1 . 1 .
1^6    | . . . 1 . . .
</Example>

Once you have a decomposition matrix it is often nice to be able
to print it. The on screen version is often good enough; <!--there is also
a 'TeX' command  which generates a \LaTeX\ version.--> There are also
functions for converting &Specht; decomposition matrices into &GAP;
matrices and visa versa (see <Ref Oper="MatrixDecompositionMatrix"/>
and <Ref Oper="DecompositionMatrixMatrix"/>).<P/>

Using the function <Ref Oper="InducedDecompositionMatrix"/>, it is possible
to induce a decomposition matrix. See also
<Ref Oper="SaveDecompositionMatrix"/> and
<Ref Oper="IsNewIndecomposable"/>, <Ref Oper="Specht"/>, <Ref Oper="Schur"/>,
and <Ref Oper="CrystalDecompositionMatrix"/>. This function requires the
package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="CrystalDecompositionMatrix" Arg="H, n[, Ordering]"/>
<Meth Name="CrystalDecompositionMatrix" Label="for an algebra and a filename"
  Arg="H, file[, Ordering]"/>
<Returns> the crystal decomposition matrix <M>D</M> of <M>H(S_n)</M> where
<M>H</M> is a Hecke algebra object returned by the function
<Ref Oper="Specht"/> (or <Ref Oper="Schur"/> ).</Returns>
<Description>
This function is similar to <Ref Oper="DecompositionMatrix"/>. The columns
of decomposition matrices correspond to projective indecomposables; the
columns of crystallized decomposition matrices correspond to the canonical
basis elements of the Fock space (see
<Ref Oper="Specht" Label="for an integer"/>). Consequently,
the entries in these matrices are polynomials (in <M>v</M>), and by
specializing (i.e. setting <M>v</M> equal to <M>1</M>; see
<Ref Oper="Specialized"/>), the decomposition matrices of <M>H</M>
are obtained (see <Ref Oper="Specht"/>).

Crystallized decomposition matrices are defined only for Hecke algebras
over a base field of characteristic zero. Unlike <Q>normal</Q>
decomposition matrices, crystallized decomposition matrices cannot be
induced.

<Example>
gap&gt; CrystalDecompositionMatrix(Specht(3), 6);
&lt;11x7 decomposition matrix&gt;
gap&gt; Display(last);
6      |   1
5,1    |   v   1
4,2    |   .   .   1
4,1^2  |   .   v   .   1
3^2    |   .   v   .   .   1
3,2,1  |   v v^2   .   v   v   1
3,1^3  |   .   .   . v^2   .   v
2^3    | v^2   .   .   .   .   v
2^2,1^2|   .   .   .   .   .   .   1
2,1^4  |   .   .   .   .   v v^2   .
1^6    |   .   .   .   . v^2   .   .
gap&gt; Specialized(last);   # set v equal to 1.
&lt;11x7 decomposition matrix&gt;
gap&gt; Display(last);
6      | 1
5,1    | 1 1
4,2    | . . 1
4,1^2  | . 1 . 1
3^2    | . 1 . . 1
3,2,1  | 1 1 . 1 1 1
3,1^3  | . . . 1 . 1
2^3    | 1 . . . . 1
2^2,1^2| . . . . . . 1
2,1^4  | . . . . 1 1 .
1^6    | . . . . 1 . .
</Example>

See also <Ref Oper="Specht"/>, <Ref Oper="Schur"/>,
<Ref Oper="DecompositionMatrix"/> and <Ref Oper="Specialized"/>. This
function requires the package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection Label="DecompositionNumber">
<Meth Name="DecompositionNumber" Arg="H, mu, nu"/>
<Meth Name="DecompositionNumber" Label="for a decomposition matrix"
  Arg="d, mu, nu"/>
<Description>
This function attempts to calculate the decomposition multiplicity of
<M>D(\nu)</M> in <M>S(\mu)</M> (equivalently, the multiplicity of
<M>S(\mu)</M> in <M>P(\nu)</M>). If <M>P(\nu)</M> is known, we just look up
the answer; if not <Ref Oper="DecompositionNumber"/> tries to calculate the
answer using <Q>row and column removal</Q> (see
<Cite Key="J" Where="Theorem 6.18"/>).<P/>

<Example>
gap&gt; H:=Specht(6);; DecompositionNumber(H,[6,4,2],[6,6]);
0
</Example>

This function requires the package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
</Section>
<!--######################################################################-->
<Section Label="partitions">
<Heading>Partitions in &Specht;</Heading>
Many of the functions in &Specht; take partitions as arguments.
Partitions are usually represented by lists in &GAP;. In &Specht;,
all the functions which expect a partition will accept their argument
either as a list or simply as a sequence of numbers. So, for example:

<Example>
gap&gt; H:=Specht(4);; Print(MakeSpecht(MakePIM(H,6,4)),"\n");
S(6,4)+S(6,3,1)+S(5,3,1,1)+S(3,3,2,1,1)+S(2,2,2,2,2)
gap&gt; Print(MakeSpecht(MakePIM(H,[6,4])),"\n");
S(6,4)+S(6,3,1)+S(5,3,1,1)+S(3,3,2,1,1)+S(2,2,2,2,2)
</Example>

Some functions require more than one argument, but the convention still
applies.

<Example>
gap&gt; ECore(3, [6,4,2]);
[ 6, 4, 2 ]
gap&gt; ECore(3, 6,4,2);
[ 6, 4, 2 ]
gap&gt; GoodNodes(3, 6,4,2);
[ false, false, 3 ]
gap&gt; GoodNodes(3, [6,4,2], 2);
3
</Example>

Basically, it never hurts to put the extra brackets in, and they can
be omitted so long as this is not ambiguous. One function where the
brackets are needed is <Ref Oper="DecompositionNumber"/> this is clear
because the function takes two partitions as its arguments.
</Section>
<Section Label="induce">
<Heading>Inducing and restricting modules</Heading>
&Specht; provides four functions <Ref Oper="RInducedModule"/>,
<Ref Oper="RRestrictedModule"/>, <Ref Oper="SInducedModule"/>
and <Ref Oper="SRestrictedModule"/> for inducing and restricting
modules. All functions can be applied to Specht modules, PIMs, and simple
modules. These functions all work by first rewriting all modules as a
linear combination of Specht modules (or <M>q</M>-Weyl modules), and then
inducing and restricting. Whenever possible the induced or restricted
module will be written in the original basis.<P/>

All of these functions can also be applied to elements of the Fock
space (see <Ref Oper="Specht"/>); in which case they correspond to the action
of the generators <M>E_i</M> and <M>F_i</M> of <M>U_q(\widehat{sl_e})</M> on
<M>\mathcal{F}</M>. There is also a function
<Ref Oper="InducedDecompositionMatrix"/> for inducing decomposition matrices.
<!--######################################################################-->
<ManSection>
<Meth Name="RInducedModule" Arg="x"/>
<Meth Name="RInducedModule" Label="for residues"
  Arg="x r1[, r2, ...]"/>
<Returns>the induced modules of the Specht
modules, principal indecomposable modules, and simple modules (more
accurately, their image in the Grothendieck ring).</Returns>
<Description>
There is an natural embedding of <M>H(S_n)</M> in <M>H(S_{n+1})</M>
which in the usual way lets us define an <E>induced</E>
<M>H(S_{n+1})</M>-module for every <M>H(S_n)</M>-module.<P/>

There is also a function <Ref Oper="SInducedModule"/> which
provides a much faster way of <M>r</M>-inducing <M>s</M> times (and inducing
<M>s</M> times).<P/>

Let <M>\mu</M> be a partition. Then the induced module
<C>RInducedModule(S(</C><M>\mu</M><C>))</C> is easy to describe: it has the
same composition factors as <M>\sum S(\nu)</M>
where <M>\nu</M> runs over all partitions whose diagrams can be obtained by
adding a single node to the diagram of <M>\mu</M>.

<Example>
gap&gt; H:=Specht(2,2);;
gap&gt; Display(RInducedModule(MakeSpecht(H,7,4,3,1)));
S(8,4,3,1)+S(7,5,3,1)+S(7,4^2,1)+S(7,4,3,2)+S(7,4,3,1^2)
gap&gt; Display(RInducedModule(MakePIM(H,5,3,1)));
P(6,3,1)+2P(5,4,1)+P(5,3,2)
gap&gt; Display(RInducedModule(MakeSimple(H,11,2,1)));
# D(&lt;x&gt;), unable to rewrite &lt;x&gt; as a sum of simples
S(12,2,1)+S(11,3,1)+S(11,2^2)+S(11,2,1^2)
</Example>

When inducing indecomposable modules and simple modules,
<Ref Oper="RInducedModule"/> first rewrites these modules as a linear
combination of Specht modules (using known decomposition matrices), and then
induces this linear combination of Specht modules. If possible &Specht; then
rewrites the induced module back in the original basis. Note that in the last
example above, the decomposition matrix for <M>S_{15}</M> is not known by
&Specht; this is why <Ref Oper="RInducedModule"/> was unable to rewrite this
module in the <M>D</M>-basis.<P/>

<E><M>r</M>-Induction</E><P/>

Two Specht modules <M>S(\mu)</M> and <M>S(\nu)</M> belong to the same block
if and only if the corresponding partitions <M>\mu</M> and <M>\nu</M> have
the same <M>e</M>-core <Cite Key="JM2"/>  (see <Ref Oper="ECore"/>). Because
the <M>e</M>-core of a partition is determined by its (multiset of) <M>e</M>
-residues, if <M>S(\mu)</M> and <M>S(\nu)</M> appear in
<C>RInducedModule(S(</C><M>\tau</M><C>))</C>, for some partition
<M>\tau</M>, then <M>S(\mu)</M> and <M>S(nu)</M> belong to the same block if
and only if <M>\mu</M> and <M>\nu</M> can be obtained by adding a node of the
same <M>e</M>-residue to the diagram of <M>\tau</M>. The second form of
<Ref Oper="RInducedModule"/> allows one to induce <Q>within blocks</Q> by
only adding nodes of some fixed <M>e</M>-residue <M>r</M>; this is known as
<E>r-induction</E>. Note that <M>0\leq r&lt;e</M>.<P/>

<Example>
gap&gt; H:=Specht(4);; Display(RInducedModule(MakeSpecht(H,5,2,1)));
S(6,2,1)+S(5,3,1)+S(5,2^2)+S(5,2,1^2)
gap&gt; Display(RInducedModule(MakeSpecht(H,5,2,1),0));
0*S()
gap&gt; Display(RInducedModule(MakeSpecht(H,5,2,1),1));
S(6,2,1)+S(5,3,1)+S(5,2,1^2)
gap&gt; Display(RInducedModule(MakeSpecht(H,5,2,1),2));
0*S()
gap&gt; Display(RInducedModule(MakeSpecht(H,5,2,1),3));
S(5,2^2)
</Example>

The function <Ref Oper="EResidueDiagram"/>, prints the diagram
of <M>\mu</M>, labeling each node with its <M>e</M>-residue. A quick check of
this diagram confirms the answers above.

<Example>
gap&gt; EResidueDiagram(H,5,2,1);
  0  1  2  3  0
  3  0
  2
true
</Example>

<E><Q>Quantized</Q> induction</E><P/>

When <Ref Oper="RInducedModule"/> is applied to the canonical basis elements
<C>MakeFockPIM(</C><M>\mu</M><C>)</C> (or more generally elements of the Fock
space; see <Ref Oper="Specht"/>), a <Q>quantum analogue</Q> of induction is
applied. More precisely, the function
<C>RInducedModule(</C><M>*,i</M><C>)</C> corresponds to the action of the
generator <M>F_i</M> of the quantum group <M>U_q(\widehat{sl_e})</M> on
<M>\mathcal{F}</M> <Cite Key="LLT"/>.

<Example>
gap&gt; H:=Specht(3);; x:=RInducedModule(MakeFockPIM(H,4,2),1,2);;
gap&gt; Display(x); Display(MakePIM(x));
Sq(6,2)+vSq(4^2)+v^2Sq(4,2^2)
Pq(6,2)
</Example>

See also <Ref Oper="SInducedModule"/>, <Ref Oper="RRestrictedModule"/> and
<Ref Oper="SRestrictedModule"/>. This function requires the package &specht;
(see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="SInducedModule" Arg="x, s"/>
<Meth Name="SInducedModule" Label="for residues"
  Arg="x, s, r"/>
<Description>
The function <Ref Oper="SInducedModule"/>, standing for <Q>string
induction</Q>, provides a more efficient way of <M>r</M>-inducing <M>s</M>
times (and a way of inducing <M>s</M> times if the residue <M>r</M> is
omitted); <M>r</M>-induction is explained in "<Ref Oper="RInducedModule"/>.

<Example>
gap&gt; H:=Specht(4);; Display(SInducedModule(MakePIM(H,5,2,1),3));
P(8,2,1) + 3P(7,3,1) + 2P(7,2^2) + 6P(6,3,2) + 6P(6,3,1^2) + 3P(6,2,1^3) + 2P(5,3^2) + P(5,2^2,1^2)
gap&gt; Display(SInducedModule(MakePIM(H,5,2,1),3,1));
P(6,3,1^2)
gap&gt; Display(RInducedModule(MakePIM(H,5,2,1),1,1,1));
6P(6,3,1^2)
</Example>

Note that the multiplicity of each summand of
<C>RInducedModule(</C><M>x,r,\ldots,r</M><C>)</C>
is divisible by <M>s!</M> and that <Ref Oper="SInducedModule"/> divides by
this constant.<P/>

As with <Ref Oper="RInducedModule"/> this function can also be applied to
elements of the Fock space (see <Ref Oper="Specht"/>), in which case the
quantum analogue of induction is used.<P/>

See also <Ref Oper="RInducedModule"/>. This function requires the
package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="RRestrictedModule" Arg="x"/>
<Meth Name="RRestrictedModule" Label="for residues"
  Arg="x r1[, r2, ...]"/>
<Returns>the corresponding module for <M>H(S_{n-1})</M> when given a module
<M>x</M> for <M>H(S_n)</M></Returns>
<Description>
The restriction of the Specht module <M>S(\mu)</M> is the linear combination
of Specht modules <M>\sum S(\nu)</M> where <M>\nu</M> runs over the
partitions whose diagrams are obtained by deleting a node from the diagram of
<M>\mu</M>. If only nodes of residue <M>r</M> are deleted then this
corresponds to first restricting <M>S(\mu)</M> and then taking one of the
block components of the restriction; this process
is known as <E><M>r</M>-restriction</E> (cf. <M>r</M>-induction in
<Ref Oper="RInducedModule"/>).<P/>

There is also a function <Ref Oper="SRestrictedModule"/> which provides a
faster way of <M>r</M>-restricting <M>s</M> times (and restricting
<M>s</M> times).<P/>

When more than one residue if given to <Ref Oper="RRestrictedModule"/> it
returns <C>RRestrictedModule(</C><M>x,r_1,r_2,\ldots,r_k</M><C>)</C>=
  <C>RRestrictedModule(
    RRestrictedModule(</C><M>x,r_1</M><C>)</C><M>,r_2,\ldots,r_k</M><C>)</C>
(cf. <Ref Oper="RInducedModule"/>).

<Example>
gap&gt; H:=Specht(6);; Display(RRestrictedModule(MakePIM(H,5,3,2,1),4));
2P(4,3,2,1)
gap&gt; Display(RRestrictedModule(MakeSimple(H,5,3,2),1));
D(5,2^2)
</Example>

<E><Q>Quantized</Q> restriction</E><P/>

As with <Ref Oper="RInducedModule"/>, when <Ref Oper="RRestrictedModule"/> is
applied to the canonical basis elements <C>MakeFockPIM(</C><M>\mu</M><C>)</C>
a quantum analogue of restriction is applied; this time,
<C>RestrictedModule(</C><M>*,i</M><C>)</C> corresponds to the action
of the generator <M>E_i</M> of <M>U_q(\widehat{sl_e})</M> on <M>\mathcalF</M>
<Cite Key="LLT"/>.<P/>

See also <Ref Oper="RInducedModule"/>, <Ref Oper="SInducedModule"/> and
<Ref Oper="SRestrictedModule"/>. This function requires the package &specht;
(see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="SRestrictedModule" Arg="x, s"/>
<Meth Name="SRestrictedModule" Label="for residues"
  Arg="x, s, r"/>
<Description>
As with <Ref Oper="SInducedModule"/> this function provides a more efficient
way of <M>r</M>-restricting <M>s</M> times, or restricting <M>s</M> times if
the residue <M>r</M> is omitted (cf. <Ref Oper="SInducedModule"/>).


<Example>
gap&gt; H:=Specht(6);; Display(SRestrictedModule(MakeSpecht(H,4,3,2),3));
3S(4,2) + 2S(4,1^2) + 3S(3^2) + 6S(3,2,1) + 2S(2^3)
gap&gt; Display(SRestrictedModule(MakePIM(H,5,4,1),2,4));
P(4^2)
</Example>

See also <Ref Oper="RInducedModule"/>, <Ref Oper="SInducedModule"/> and
<Ref Oper="RRestrictedModule"/>. This function requires the package &specht;
(see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
</Section>
<!--######################################################################-->
<Section>
<Heading>Operations on decomposition matrices</Heading>
&Specht; is a package for computing decomposition matrices; this section
describes the functions available for accessing these matrices directly.
In addition to decomposition matrices, &Specht; also calculates the
<Q>crystallized decomposition matrices</Q> of <Cite Key="LLT"/> and the
<Q>adjustment matrices</Q> introduced by James <Cite Key="J"/> (and Geck
<Cite Key="G"/>).<P/>

Throughout &Specht; we place an emphasis on calculating the projective
indecomposable modulesand hence upon the columns of decomposition
matrices. This approach seems more efficient than the traditional approach
of calculating decomposition matrices by rows; ideally both approaches
should be combined (as is done by <Ref Oper="IsNewIndecomposable"/>).<P/>

In principle, all decomposition matrices for all Hecke algebras defined
over a field of characteristic zero are available from within &Specht;. In
addition, the decomposition matrices for all <M>q</M>-Schur algebras with
<M>n\leq10</M> and all values of <M>e</M> and the <M>p</M>-modular
decomposition matrices of the symmetric groups <M>S_n</M> for <M>n&lt;15</M>
are in the &Specht; library files.<P/>

If you are using &Specht; regularly to do calculations involving certain
values of <M>e</M> it would be advantageous to have &Specht; calculate and
save the first 20 odd decomposition matrices that you are interested in. So,
for <M>e=4</M> use the commands:

<Example>
gap&gt; H:=Specht(4);; for n in [8..20] do
>      SaveDecompositionMatrix(DecompositionMatrix(H,n));
>    od;
</Example>

Alternatively, you could save the crystallized decomposition matrices.
Note that for <M>n&lt;2e</M> the decomposition matrices are known (by
&Specht;) and easy to compute.
<!--######################################################################-->
<ManSection>
<Meth Name="InducedDecompositionMatrix" Arg="d"/>
<Description>
If <M>d</M> is the decomposition matrix of <M>H(S_n)</M>, then
<C>InducedDecompositionMatrix(</C><M>d</M><C>)</C> attempts to calculate the
decomposition matrix of <M>H(S_{n+1})</M>. It does this by extracting each
projective indecomposable from <M>d</M> and inducing these modules to obtain
projective modules for <M>H(S_{n+1})</M>.
<Ref Oper="InducedDecompositionMatrix"/> then tries
to decompose these projectives using the function
<Ref Oper="IsNewIndecomposable"/>. In general there will be columns of the
decomposition matrix which <Ref Oper="InducedDecompositionMatrix"/> is unable
to decompose and these will have to be calculated <Q>by hand</Q>.
<Ref Oper="InducedDecompositionMatrix"/> prints a list of those columns of
the decomposition matrix which it is unable to calculate (this list is also
printed by the function <Ref Oper="MissingIndecomposables"/>).

<Example>
gap&gt; d:=DecompositionMatrix(Specht(3,3),14);
&lt;135x57 decomposition matrix&gt;
gap&gt; InducedDecompositionMatrix(d);
# Inducing....
The following projectives are missing from &lt;d&gt;:
    [ 15 ]  [ 8, 7 ]
&lt;176x70 decomposition matrix&gt;
</Example>

Note that the missing indecomposables come in <Q>pairs</Q> which map to
each other under the Mullineux map (see <Ref Oper="MullineuxMap"/>).<P/>

Almost all of the decomposition matrices included in &Specht; were
calculated directly by <Ref Oper="InducedDecompositionMatrix"/>. When
<M>n</M> is <Q>small</Q> <Ref Oper="InducedDecompositionMatrix"/> is usually
able to return the full decomposition matrix for <M>H(S_n)</M>.

Finally, although the <Ref Oper="InducedDecompositionMatrix"/> can also be
applied to the decomposition matrices of the <M>q</M>-Schur algebras
(see <Ref Oper="Schur"/>), <Ref Oper="InducedDecompositionMatrix"/> is much
less successful in inducing these decomposition matrices because it contains
no special routines for dealing with the indecomposable modules of the
<M>q</M>-Schur algebra which are indexed by <M>e</M>-singular partitions.
Note also that we use a non-standard labeling of the decomposition matrices
of <M>q</M>-Schur algebras; see <Ref Oper="Schur"/>.
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="IsNewIndecomposable" Arg="d, x,[, mu]"/>
<Returns><K>true</K> if it is able to show that <M>x</M> is indecomposable
(and this indecomposable is not already listed in <M>d</M>), and <K>false</K>
otherwise.</Returns>
<Description>
<Ref Oper="IsNewIndecomposable"/> is the function which does all of the hard
work when the function <Ref Oper="InducedDecompositionMatrix"/> is applied to
decomposition matrices. <Ref Oper="IsNewIndecomposable"/> will also print a
brief description of its findings, giving an upper and lower bound on the
<E>first</E> decomposition number <M>\mu</M> for which it is unable to
determine the multiplicity of <M>S(\mu)</M> in <M>x</M>.<P/>

<Ref Oper="IsNewIndecomposable"/> works by running through all of the
partitions <M>\nu</M> such that <M>P(\nu)</M> could be a summand of <M>x</M>
and it uses various results, such as the <M>q</M>-Schaper theorem of
<Cite Key="JM2"/> (see <Ref Oper="Schaper"/>),
the Mullineux map (see <Ref Oper="MullineuxMap"/>) and inducing simple
modules, to determine if <M>P(\nu)</M> does indeed split off. In addition,
if <M>d</M> is the decomposition matrix for <M>H(S_n)</M> then
<Ref Oper="IsNewIndecomposable"/> will probably use some of the decomposition
matrices of <M>H(S_m)</M> for <M>m\leq n</M>, if they are known. Consequently
it is a good idea to save decomposition matrices as they are calculated (see
<Ref Oper="SaveDecompositionMatrix"/>).<P/>

For example, in calculating the <M>2</M>-modular decomposition matrices of
<M>S_{r}</M> the first projective which
<Ref Oper="InducedDecompositionMatrix"/> is unable to calculate is
<M>P(10)</M>.

<Example>
gap&gt; H:=Specht(2,2);;
gap&gt; d:=InducedDecompositionMatrix(DecompositionMatrix(H,9));;
# Inducing.
# The following projectives are missing from &lt;d&gt;:
#  [ 10 ]
</Example>

(In fact, given the above commands, &Specht; will return the full
decomposition matrix for <M>S_{10}</M> because this matrix is in the library;
these were the commands that were used to calculate the decomposition matrix
in the library.)<P/>

By inducing <M>P(9)</M> we can find a projective <M>H</M>-module which
contains <M>P(10)</M>. We can then use <Ref Oper="IsNewIndecomposable"/>
to try and decompose this induced module into a sum of PIMs.

<Example>
gap&gt; SizeScreen([80,20]);; x:=RInducedModule(MakePIM(H,9),1);; Display(x);
# P(&lt;x&gt;), unable to rewrite &lt;x&gt; as a sum of projectives
S(10) + S(9,1) + S(8,2) + 2S(8,1^2) + S(7,3) + 2S(7,1^3) + 3S(6,3,1) + 3S(6,2^\
2) + 4S(6,2,1^2) + 2S(6,1^4) + 4S(5,3,2) + 5S(5,3,1^2) + 5S(5,2^2,1) + 2S(5,1^\
5) + 2S(4^2,2) + 2S(4^2,1^2) + 2S(4,3^2) + 5S(4,3,1^3) + 2S(4,2^3) + 5S(4,2^2,\
1^2) + 4S(4,2,1^4) + 2S(4,1^6) + 2S(3^3,1) + 2S(3^2,2^2) + 4S(3^2,2,1^2) + 3S(\
3^2,1^4) + 3S(3,2^2,1^3) + 2S(3,1^7) + S(2^3,1^4) + S(2^2,1^6) + S(2,1^8) + S(\
1^10)
gap&gt; IsNewIndecomposable(d,x);
# The multiplicity of S(6,3,1) in P(10) is at least 1 and at most 2.
false
gap&gt; Display(x);
S(10) + S(9,1) + S(8,2) + 2S(8,1^2) + S(7,3) + 2S(7,1^3) + 2S(6,3,1) + 2S(6,2^\
2) + 3S(6,2,1^2) + 2S(6,1^4) + 3S(5,3,2) + 4S(5,3,1^2) + 4S(5,2^2,1) + 2S(5,1^\
5) + 2S(4^2,2) + 2S(4^2,1^2) + 2S(4,3^2) + 4S(4,3,1^3) + 2S(4,2^3) + 4S(4,2^2,\
1^2) + 3S(4,2,1^4) + 2S(4,1^6) + 2S(3^3,1) + 2S(3^2,2^2) + 3S(3^2,2,1^2) + 2S(\
3^2,1^4) + 2S(3,2^2,1^3) + 2S(3,1^7) + S(2^3,1^4) + S(2^2,1^6) + S(2,1^8) + S(\
1^10)
</Example>

Notice that some of the coefficients of the Specht modules in <M>x</M> have
changed; this is because <Ref Oper="IsNewIndecomposable"/> was able to
determine that the multiplicity of <M>S(6,3,1)</M> was at most <M>2</M> and
so it subtracted one copy of <M>P(6,3,1)</M> from <M>x</M>.<P/>

In this case, the multiplicity of <M>S(6,3,1)</M> in <M>P(10)</M> is easy to
resolve because general theory says that this multiplicity must be odd.
Therefore, <M>x-P(6,3,1)</M> is projective. After subtracting <M>P(6,3,1)</M>
from <M>x</M> we again use <Ref Oper="IsNewIndecomposable"/> to see if
<M>x</M> is now indecomposable. We can tell <Ref Oper="IsNewIndecomposable"/>
that all of the multiplicities up to and including <M>S(6,3,1)</M> have
already been checked by giving it the addition argument <M>\mu=[6,3,1]</M>.

<Example>
gap&gt; x:=x-MakePIM(d,6,3,1);; IsNewIndecomposable(d,x,6,3,1);
true
</Example>

Consequently, <M>x=P(10)</M> and we add it to the decomposition matrix
<M>d</M> (and save it).

<Example>
gap&gt; AddIndecomposable(d,x); SaveDecompositionMatrix(d);
</Example>

A full description of what <Ref Oper="IsNewIndecomposable"/> does can be
found by reading the comments in <F>specht.gi</F>. Any suggestions or
improvements on this function would be especially welcome.<P/>

See also <Ref Oper="DecompositionMatrix"/> and
<Ref Oper="InducedDecompositionMatrix"/>. This function requires the package
&specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="InvertDecompositionMatrix" Arg="d"/>
<Returns>inverse of the (<M>e</M>-regular part of) <M>d</M>, where <M>d</M>
is a decomposition matrix, or crystallized decomposition matrix, of a Hecke
algebra or <M>q</M>-Schur algebra.</Returns>
<Description>
If part of the decomposition matrix <M>d</M> is unknown then
<Ref Oper="InvertDecompositionMatrix"/> will invert as much of <M>d</M>
as possible.

<Example>
gap&gt; H:=Specht(4);; d:=CrystalDecompositionMatrix(H,5);;
gap&gt; Display(InvertDecompositionMatrix(d));
5    |   1
4,1  |   .   1
3,2  |  -v   .   1
3,1^2|   .   .   .   1
2^2,1| v^2   .  -v   .   1
2,1^3|   .   .   .   .   .   1
</Example>

See also <Ref Oper="DecompositionMatrix"/> and
<Ref Oper="CrystalDecompositionMatrix"/>. This function requires the package
&specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="AdjustmentMatrix" Arg="dp, d"/>
<Returns>the adjustment matrix <M>a</M></Returns>
<Description>
James <Cite Key="J"/> noticed and Geck <Cite Key="G"/> proved, that the
decomposition matrices <M>dp</M> for Hecke algebras defined over fields of
positive characteristic admit a factorization <M>dp = d \cdot a</M>
where <M>d</M> is a decomposition matrix for a suitable Hecke algebra
defined over a field of characteristic zero and <M>a</M> is the so-called
<E>adjustment matrix</E>.

<Example>
gap&gt; H:=Specht(2);; Hp:=Specht(2,2);;
gap&gt; d:=DecompositionMatrix(H,13);; dp:=DecompositionMatrix(Hp,13);;
gap&gt; a:=AdjustmentMatrix(dp,d);
&lt;18x18 decomposition matrix&gt;
gap&gt; Display(a);
13     | 1
12,1   | . 1
11,2   | 1 . 1
10,3   | . . . 1
10,2,1 | . . . . 1
9,4    | 1 . 1 . . 1
9,3,1  | 2 . . . . . 1
8,5    | . 1 . . . . . 1
8,4,1  | 1 . . . . . . . 1
8,3,2  | . 2 . . . . . 1 . 1
7,6    | 1 . . . . 1 . . . . 1
7,5,1  | . . . . . . 1 . . . . 1
7,4,2  | 1 . 1 . . 1 . . . . 1 . 1
7,3,2,1| . . . . . . . . . . . . . 1
6,5,2  | . 1 . . . . . 1 . 1 . . . . 1
6,4,3  | 2 . . . 1 . . . . . . . . . . 1
6,4,2,1| . 2 . 1 . . . . . . . . . . . . 1
5,4,3,1| 4 . 2 . . . . . . . . . . . . . . 1
gap&gt; MatrixDecompositionMatrix(dp)=
>           MatrixDecompositionMatrix(d)*MatrixDecompositionMatrix(a);
true
</Example>

In the last line we have checked our calculation.<P/>

See also <Ref Oper="DecompositionMatrix"/> and
<Ref Oper="CrystalDecompositionMatrix"/>. This function requires the package
&specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="SaveDecompositionMatrix" Arg="d"/>
<Meth Name="SaveDecompositionMatrix" Label="for a filename"
  Arg="d, filename"/>
<Description>
The function <Ref Oper="SaveDecompositionMatrix"/> saves the decomposition
matrix <M>d</M>. After a decomposition matrix has been saved, the functions
<Ref Oper="MakeSpecht"/>, <Ref Oper="MakePIM"/> and <Ref Oper="MakeSimple"/>
will automatically access it as needed. So, for example, before saving
<M>d</M> in order to retrieve the indecomposable <M>P(\mu)</M>
from <M>d</M> it is necessary to type <C>MakePIM(</C><M>d, \mu</M><C>)</C>;
once <M>d</M> has been saved, the command <C>MakePIM(</C><M>\mu</M><C>)</C>
suffices.<P/>

Since <Ref Oper="InducedDecompositionMatrix"/> consults the decomposition
matrices for smaller <M>n</M>, if they are available, it is advantageous to
save decomposition matrices as they are calculated. For example, over a
field of characteristic <M>5</M>, the decomposition matrices for the
symmetric groups <M>S_n</M> with <M>n\leq 20</M> can be calculated as
follows:

<Example>
gap&gt; H:=Specht(5,5);;
gap&gt; d:=DecompositionMatrix(H,9);;
gap&gt; for r in [10..20] do
>      d:=InducedDecompositionMatrix(d);
>      SaveDecompositionMatrix(d);
>    od;
# Inducing...
# Inducing....
# Inducing....
# Inducing.....
# Inducing......
# Inducing.......
# Inducing........
# Inducing..........
# Inducing............
# Inducing..............
# Inducing.................
</Example>

If your Hecke algebra object <M>H</M> is defined using a non-standard
valuation map (see <Ref Oper="Specht"/>) then it is also necessary to set the
string <M>HeckeRing</M>, or to supply the function with a <M>filename</M>
before it will save your matrix. <Ref Oper="SaveDecompositionMatrix"/> will
also save adjustment matrices and the various other matrices that appear in
&Specht; (they can be read back in using <Ref Oper="DecompositionMatrix"/>).
Each matrix has a default filename which you can over ride by supplying a
<M>filename</M>. Using non-standard file names will stop &Specht; from
automatically accessing these matrices in future.

See also <Ref Oper="DecompositionMatrix"/> and
<Ref Oper="CrystalDecompositionMatrix"/>. This function requires the package
&specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="CalculateDecompositionMatrix" Arg="H, n"/>
<Description>
<Ref Oper="CalculateDecompositionMatrix"/> is similar to the function
<Ref Oper="DecompositionMatrix"/> in that both functions try to
return the decomposition matrix <M>d</M> of <M>H(S_n)</M>; the difference is
that this function tries to calculate this matrix whereas the later reads
the matrix from the library files (in characteristic zero both functions
apply the algorithm of <Cite Key="LLT"/> to compute <M>d</M>). In effect
this function is only needed when working with Hecke algebras defined over
fields of positive characteristic (or when you wish to avoid the libraries).

For example, if you want to do calculations with the decomposition matrix of
the symmetric group <M>S_{15}</M> over a field of characteristic two,
<Ref Oper="DecompositionMatrix"/> returns fail whereas
<Ref Oper="CalculateDecompositionMatrix"/>
returns a part of the decomposition matrix.

<Example>
gap&gt; H:=Specht(2,2);; d:=DecompositionMatrix(H,15);
# This decomposition matrix is not known; use CalculateDecompositionMatrix()
# or InducedDecompositionMatrix() to calculate with this matrix.
fail
gap&gt; d:=CalculateDecompositionMatrix(H,15);;
# Projective indecomposable P(6,4,3,2) not known.
# Projective indecomposable P(6,5,3,1) not known.
# Projective indecomposable P(6,5,4) not known.
# Projective indecomposable P(7,4,3,1) not known.
# Projective indecomposable P(7,5,2,1) not known.
# Projective indecomposable P(7,5,3) not known.
# Projective indecomposable P(7,6,2) not known.
# Projective indecomposable P(8,4,2,1) not known.
# Projective indecomposable P(8,4,3) not known.
# Projective indecomposable P(8,5,2) not known.
# Projective indecomposable P(8,6,1) not known.
# Projective indecomposable P(8,7) not known.
# Projective indecomposable P(9,3,2,1) not known.
# Projective indecomposable P(9,4,2) not known.
# Projective indecomposable P(9,5,1) not known.
# Projective indecomposable P(9,6) not known.
# Projective indecomposable P(10,3,2) not known.
# Projective indecomposable P(10,4,1) not known.
# Projective indecomposable P(10,5) not known.
# Projective indecomposable P(11,3,1) not known.
# Projective indecomposable P(11,4) not known.
# Projective indecomposable P(12,2,1) not known.
# Projective indecomposable P(12,3) not known.
# Projective indecomposable P(13,2) not known.
# Projective indecomposable P(14,1) not known.
# Projective indecomposable P(15) not known.
gap&gt; SizeScreen([80,20]);; MissingIndecomposables(d);
The following projectives are missing from &lt;d&gt;:
    [ 15 ]  [ 14, 1 ]  [ 13, 2 ]  [ 12, 3 ]  [ 12, 2, 1 ]  [ 11, 4 ]
[ 11, 3, 1 ]  [ 10, 5 ]  [ 10, 4, 1 ]  [ 10, 3, 2 ]  [ 9, 6 ]  [ 9, 5, 1 ]
[ 9, 4, 2 ]  [ 9, 3, 2, 1 ]  [ 8, 7 ]  [ 8, 6, 1 ]  [ 8, 5, 2 ]  [ 8, 4, 3 ]
[ 8, 4, 2, 1 ]  [ 7, 6, 2 ]  [ 7, 5, 3 ]  [ 7, 5, 2, 1 ]  [ 7, 4, 3, 1 ]
[ 6, 5, 4 ]  [ 6, 5, 3, 1 ]  [ 6, 4, 3, 2 ]
</Example>

Actually, you are much better starting with the decomposition matrix of
<M>S_{14}</M> and then applying <Ref Oper="InducedDecompositionMatrix"/>
to this matrix.

See also <Ref Oper="DecompositionMatrix"/>. This function requires the
package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="MatrixDecompositionMatrix" Arg="d"/>
<Returns>the &GAP; matrix corresponding to the &Specht; decomposition
matrix <M>d</M></Returns>
<Description>
The rows and columns of <M>d</M> are sorted by the ordering stored in the
internal algebra object of the matrix <M>d</M>.

<Example>
gap&gt; SizeScreen([80,20]);;
gap&gt; MatrixDecompositionMatrix(DecompositionMatrix(Specht(3),5));
[ [ 1, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0 ], [ 0, 1, 1, 0, 0 ], [ 0, 0, 0, 1, 0 ],
  [ 1, 0, 0, 0, 1 ], [ 0, 0, 0, 0, 1 ], [ 0, 0, 1, 0, 0 ] ]
</Example>

See also <Ref Oper="DecompositionMatrix"/> and
<Ref Oper="DecompositionMatrixMatrix"/>. This function requires the package
&specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="DecompositionMatrixMatrix" Arg="H, m, n"/>
<Returns>the &Specht; decomposition matrix corresponding to the &GAP; matrix
<M>m</M></Returns>
<Description>
If <M>p</M> is the number of partitions of <M>n</M> and <M>r</M> the number
of <M>e</M>-regular partitions of <M>n</M>, then <M>m</M> must be either
<M>r\times r</M>, <M>p\times r</M> or <M>p\times p</M>. The rows and columns
of <M>m</M> are assumed to be indexed by partitions sorted by the ordering
stored in the algebra object <M>H</M> (see <Ref Oper="Specht"/>).

<Example>
gap&gt; H:=Specht(3);;
gap&gt; m:=[ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 1, 0, 1, 0 ],
>         [ 0, 0, 0, 1 ], [ 0, 0, 1, 0 ] ];;
gap&gt; Display(DecompositionMatrixMatrix(H,m,4));
4    | 1
3,1  | . 1
2^2  | 1 . 1
2,1^2| . . . 1
1^4  | . . 1 .
</Example>

See also <Ref Oper="DecompositionMatrix"/> and
<Ref Oper="MatrixDecompositionMatrix"/>. This function requires the package
&specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="AddIndecomposable" Arg="d, x"/>
<Description>
<Ref Oper="AddIndecomposable"/> inserts the indecomposable module <M>x</M>
into the decomposition matrix <M>d</M>. If <M>d</M> already contains the
indecomposable <M>d</M> then a warning is printed. The function
<Ref Oper="AddIndecomposable"/> also calculates <C>MullineuxMap(</C>
<M>x</M><C>)</C> (see <Ref Oper="MullineuxMap"/>) and adds this
indecomposable to <M>d</M> (or checks to see that it agrees with the
corresponding entry of <M>d</M> if this indecomposable is already in
<M>d</M>).<P/>

See <Ref Oper="IsNewIndecomposable"/> for an example.
See also <Ref Oper="DecompositionMatrix"/> and
<Ref Oper="CrystalDecompositionMatrix"/>. This function requires the package
 &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="RemoveIndecomposable" Arg="d, mu"/>
<Description>
The function <Ref Oper="RemoveIndecomposable"/> removes the column from
<M>d</M> which corresponds to <M>P(\mu)</M>. This is sometimes useful when
trying to calculate a new decomposition matrix using &Specht; and want to
test a possible candidate for a yet to be identified PIM.<P/>

See also <Ref Oper="DecompositionMatrix"/> and
<Ref Oper="CrystalDecompositionMatrix"/>. This function requires the package
 &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="MissingIndecomposables" Arg="d"/>
<Description>
The function <Ref Oper="MissingIndecomposables"/> prints the list of
partitions corresponding to the indecomposable modules which are not listed
in <M>d</M>.<P/>

See also <Ref Oper="DecompositionMatrix"/> and
<Ref Oper="CrystalDecompositionMatrix"/>. This function requires the package
&specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
</Section>
<!--######################################################################-->
<Section>
<Heading>Calculating dimensions</Heading>
&Specht; has two functions for calculating the dimensions of modules
of Hecke algebras; <Ref Oper="SimpleDimension"/> and
<Ref Oper="SpechtDimension"/>. As yet, &Specht; does not know how to
calculate the dimensions of modules for <M>q</M>-Schur algebras (these
depend up on <M>q</M>).
<!--######################################################################-->
<ManSection>
<Meth Name="SimpleDimension" Arg="d"/>
<Meth Name="SimpleDimension" Label="for an algebra object and an integer"
  Arg="H, n"/>
<Meth Name="SimpleDimension" Label="for a partition"
  Arg="H|d, mu"/>
<Description>
In the first two forms, <Ref Oper="SimpleDimension"/> prints the dimensions
of all of the simple modules specified by <M>d</M> or for the Hecke algebra
<M>H(S_n)</M> respectively. If a partition <M>\mu</M> is supplied, as in the
last form, then the dimension of the simple module <M>D(\mu)</M> is
returned.  At present the function is not implemented for the simple
modules of the <M>q</M>-Schur algebras.

<Example>
gap&gt; H:=Specht(6);;
gap&gt; SimpleDimension(H,11,3);
272
gap&gt; d:=DecompositionMatrix(H,5);; SimpleDimension(d,3,2);
5
gap&gt; SimpleDimension(d);
5     : 1
4,1   : 4
3,2   : 5
3,1^2 : 6
2^2,1 : 5
2,1^3 : 4
1^5   : 1
true
</Example>

This function requires the package &specht;
(see <Ref Func="LoadPackage" BookName="Reference"/>).

</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="SpechtDimension" Arg="mu"/>
<Returns>the dimension of the Specht module <M>S(\mu)</M></Returns>
<Description>
<M>\dim S(\mu)</M> is equal to the number of standard <M>\mu</M>-tableaux;
the answer is given by the hook length formula (see <Cite Key="JK"/>).

<Example>
gap&gt; SpechtDimension(6,3,2,1);
5632
</Example>

See also <Ref Oper="SimpleDimension"/>. This function requires the package
&specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
</Section>
<Section>
<Heading>Combinatorics on Young diagrams</Heading>
These functions range from the representation theoretic <M>q</M>-Schaper
theorem and Kleshchev's algorithm for the Mullineux map through to
simple combinatorial operations like adding and removing rim hooks from
Young diagrams.
<!--######################################################################-->
<ManSection>
<Meth Name="Schaper" Arg="H, mu"/>
<Returns>a linear combination of Specht modules which have the same
composition factors as the sum of the modules in the <Q>Jantzen filtration
</Q> of <M>S(\mu)</M>; see <Cite Key="JM2"/>. In particular, if <M>\nu</M>
strictly dominates <M>\mu</M> then <M>D(\nu)</M> is a composition factor of
<M>S(\mu)</M> if and only if it is a composition factor of
<C>Schaper(</C><M>\mu</M><C>)</C>.</Returns>
<Description>
<Ref Oper="Schaper"/> uses the valuation map attached to <M>H</M> (see
<Ref Oper="Specht"/> and <Cite Key="JM2"/>).<P/>

One way in which the <M>q</M>-Schaper theorem can be applied is as follows.
Suppose that we have a projective module <M>x</M>, written as a linear
combination of Specht modules and suppose that we are trying to decide
whether the projective indecomposable <M>P(\mu)</M> is a direct summand of
<M>x</M>. Then, providing that we know that <M>P(\nu)</M> is not a summand
of <M>x</M> for all (<M>e</M>-regular) partitions <M>\nu</M> which strictly
dominate <M>\mu</M> (see <Ref Oper="Dominates"/>), <M>P(\mu)</M> is a
summand of <M>x</M> if and only if <C>InnerProduct(Schaper(
</C><M>H,\mu</M><C>)</C>,<M>x</M><C>)</C> is non-zero (note, in particular,
that we don't need to know the indecomposable <M>P(\mu)</M> in order to
perform this calculation).<P/>

The <M>q</M>-Schaper theorem can also be used to check for irreduciblity; in
fact, this is the basis for the criterion employed by
<Ref Oper="IsSimpleModule"/>.

<Example>
gap&gt; SizeScreen([80,20]);; H:=Specht(2);;
gap&gt; Display(Schaper(H,9,5,3,2,1));
S(17,2,1) - S(15,2,1^3) + S(13,2^3,1) - S(11,3^2,2,1) + S(10,4,3,2,1) - S(9,8,\
3) - S(9,8,1^3) + S(9,6,3,2) + S(9,6,3,1^2) + S(9,6,2^2,1)
gap&gt; Display(Schaper(H,9,6,5,2));
0S()
</Example>

The last calculation shows that <M>S(9,6,5,2)</M> is irreducible when
<M>R</M> is a field of characteristic zero and <M>e=2</M> (cf.
<C>IsSimpleModule(</C><M>H,9,6,5,2</M><C>)</C>).

This function requires the package &specht;
(see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="IsSimpleModule" Arg="H, mu"/>
<Returns><K>true</K> if <M>S(\mu)</M> is simple and <K>false</K> otherwise.
</Returns>
<Description>
<M>\mu</M> an <M>e</M>-regular partition.<P/>

This calculation uses the valuation function of <M>H</M>;
see <Ref Oper="Specht"/>. Note that the criterion used by
<Ref Oper="IsSimpleModule"/> is completely combinatorial;
it is derived from the <M>q</M>-Schaper theorem <Cite Key="JM2"/>.

<Example>
gap&gt; H:=Specht(3);;
gap&gt; IsSimpleModule(H,45,31,24);
false
</Example>

See also <Ref Oper="Schaper"/>. This function requires the package
&specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="MullineuxMap" Arg="e|H, mu"/>
<Description>
The sign representation <M>D(1^n)</M> of the Hecke algebra is the (one
dimensional) representation sending <M>T_w</M> to <M>(-1)^{l(w)}</M>.
The Hecke algebra <M>H</M> is not a Hopf algebra so there is no well defined
action of <M>H</M> upon the tensor product of two <M>H</M>-modules; however,
there is an outer automorphism <M>#</M> of <M>H</M> which corresponds to
tensoring with <M>D(1^n)</M>. This sends an irreducible module <M>D(\mu)</M>
to an irreducible <M>D(\mu)^\#\cong D(\mu^\#)</M> for some <M>e</M>-regular
partition <M>\mu^\#</M>. In the symmetric group case, Mullineux gave a
conjectural algorithm for calculating <M>\mu^\#</M>; consequently the map
sending <M>\mu</M> to <M>\mu^\#</M> is known as the <E>Mullineux map</E>.<P/>

Deep results of Kleshchev <Cite Key="K"/> for the symmetric group give
another (proven) algorithm for calculating the partition <M>\mu^\#</M> (Ford
and Kleshchev have deduced Mullineux's conjecture from this). Using the
canonical basis, it was shown by <Cite Key="LLT"/> that the natural
generalization of Kleshchev's algorithm to <M>H</M> gives the Mullineux map
for Hecke algebras over fields of characteristic zero. The general case
follows from this, so the Mullineux map is now known for all Hecke algebras.
<P/>
Kleshchev's map is easy to describe; he proved that if <M>gns</M> is any
good node sequence for <M>\mu</M>, then the sequence obtained from <M>gns</M>
by replacing each residue <M>r</M> by <M>-r\bmod e</M> is a good node
sequence for <M>\mu^\#</M> (see <Ref Oper="GoodNodeSequence"/>).

<Example>
gap&gt; MullineuxMap(Specht(2),12,5,2);
[ 12, 5, 2 ]
gap&gt; MullineuxMap(Specht(4),12,5,2);
[ 4, 4, 4, 2, 2, 1, 1, 1 ]
gap&gt; MullineuxMap(Specht(6),12,5,2);
[ 4, 3, 2, 2, 2, 2, 2, 1, 1 ]
gap&gt; MullineuxMap(Specht(8),12,5,2);
[ 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1 ]
gap&gt; MullineuxMap(Specht(10),12,5,2);
[ 3, 3, 3, 3, 2, 1, 1, 1, 1, 1 ]
</Example>
</Description>
<Returns>the image of <M>\mu</M> under the Mullineux map</Returns>
<Meth Name="MullineuxMap" Label="for a decomposition matrix" Arg="d, mu"/>
<Description>
The Mullineux map can also be calculated using a decomposition matrix.
To see this recall that <Q>tensoring</Q> a Specht module <M>S(\mu)</M> with
the sign representation yields a module isomorphic to the dual of
<M>S(\lambda)</M>, where <M>\lambda</M> is the partition conjugate to
<M>\mu</M>. It follows that <M>d_{\mu\nu}=d_{\lambda\nu^\#}</M> for all
<M>e</M>-regular partitions <M>\nu</M>. Therefore, if <M>\mu</M> is the last
partition in the lexicographic order such that <M>d_{\mu\nu}\neq 0</M> then
we must have <M>\nu^\#=\lambda</M>. The second form of
<Ref Oper="MullineuxMap"/> uses <M>d</M> to calculate <M>\mu^\#</M> rather
than the Kleshchev-<Cite Key="LLT"/> result.

</Description>
<Meth Name="MullineuxMap" Label="for a module" Arg="x"/>
<Returns>returns <M>x^#</M>, the image of <M>x</M> under <M>#</M>.</Returns>
<Description>
Note that the above remarks show that <M>P(\mu)</M>
is mapped to <M>P(\mu^\#)</M> via the Mullineux map; this observation is
useful when calculating decomposition matrices (and is used by the
function <Ref Oper="InducedDecompositionMatrix"/>).<P/>

See also <Ref Oper="GoodNodes"/> and <Ref Oper="GoodNodeSequence"/>. This
function requires the package &specht; (see
<Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="MullineuxSymbol" Arg="e|H, mu"/>
<Returns>the Mullineux symbol of the <M>e</M>-regular partition <M>\mu</M>.
</Returns>
<Description>
<Example>
gap&gt; MullineuxSymbol(5,[8,6,5,5]);
[ [ 10, 6, 5, 3 ], [ 4, 4, 3, 2 ] ]
</Example>

See also <Ref Oper="PartitionMullineuxSymbol"/>. This function requires the
package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="PartitionMullineuxSymbol" Arg="e|H, ms"/>
<Returns>the <M>e</M>-regular partition corresponding to the given
Mullineux symbol <M>ms</M></Returns>
<Description>
<Example>
gap&gt; PartitionMullineuxSymbol(5, MullineuxSymbol(5,[8,6,5,5]) );
[ 8, 6, 5, 5 ]
</Example>

See also <Ref Oper="MullineuxSymbol"/>. This function requires the package
&specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="GoodNodes" Arg="e|H, mu"/>
<Returns>a list of the rows of <M>\mu</M> which end in a good node. The good
node of residue <M>r</M> (if it exists) is the <M>(r+1)</M>-st element in
this list.</Returns>
<Meth Name="GoodNodes" Label="for residues" Arg="e|H, mu, r"/>
<Returns> the number of the row which ends with the good node of residue
<M>r</M> or <K>fail</K> if there is no good node of residue <M>r</M>.
</Returns>
<Description>
Given a partition and an integer <M>e</M>, Kleshchev [K] defined the notion
of <E>good node</E> for each residue <M>r</M> (<M>0\leq r&lt;e</M>). When
<M>e</M> is prime and <M>\mu</M> is <M>e</M>-regular, Kleshchev showed that
the good nodes describe the restriction of the socle of <M>D(\mu)</M> in the
symmetric group case. Brundan <Cite Key="B"/> has recently generalized this
result to the Hecke algebra.<P/>

By definition, there is at most one good node for each residue <M>r</M> and
this node is a removable node (in the diagram of <M>\mu</M>).

<Example>
gap&gt; GoodNodes(5,[5,4,3,2]);
[ fail, fail, 2, fail, 1 ]
gap&gt; GoodNodes(5,[5,4,3,2],0);
fail
gap&gt; GoodNodes(5,[5,4,3,2],4);
1
</Example>

The good nodes also determine the Kleshchev-Mullineux map (see
<Ref Oper="GoodNodeSequence"/> and <Ref Oper="MullineuxMap"/>). This
function requires the package &specht;
(see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="NormalNodes" Arg="e|H, mu"/>
<Returns>the numbers of the rows of <M>\mu</M> which end in one of
Kleshchev's <Cite Key="K"/> normal nodes.</Returns>
<Meth Name="NormalNodes" Arg="e|H, mu, r"/>
<Returns> the rows corresponding to normal nodes of the specified residue.
</Returns>
<Description>
<Example>
gap&gt; NormalNodes(5,[6,5,4,4,3,2,1,1,1]);
[ [ 1, 4 ], [  ], [  ], [ 2, 5 ], [  ] ]
gap&gt; NormalNodes(5,[6,5,4,4,3,2,1,1,1],0);
[ 1, 4 ]
</Example>
See also <Ref Oper="GoodNodes"/>. This function requires the package
&specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="GoodNodeSequence" Arg="e|H, mu"/>
<Description>
Given an <M>e</M>-regular partition <M>\mu</M> of <M>n</M>, a <E>good node
sequence</E> for <M>\mu</M> is a sequence <M>gns</M> of <M>n</M> residues
such that <M>\mu</M> has a good node of residue <M>r</M>, where <M>r</M> is
the last residue in <M>gns</M> and the first <M>n-1</M> residues in
<M>gns</M> are a good node sequence for the partition obtained from
<M>\mu</M> by deleting its (unique) good node with residue <M>r</M>
(see <Ref Oper="GoodNodes"/>). In general, <M>\mu</M> will have more than
one good node sequence; however, any good node sequence uniquely determines
<M>\mu</M> (see <Ref Oper="PartitionGoodNodeSequence"/>).

<Example>
gap&gt; H:=Specht(4);; GoodNodeSequence(H,4,3,1);
[ 0, 3, 1, 0, 2, 2, 1, 3 ]
gap&gt; GoodNodeSequence(H,4,3,2);
[ 0, 3, 1, 0, 2, 2, 1, 3, 3 ]
gap&gt; GoodNodeSequence(H,4,4,2);
[ 0, 3, 1, 0, 2, 2, 1, 3, 3, 2 ]
gap&gt; GoodNodeSequence(H,5,4,2);
[ 0, 3, 1, 0, 2, 2, 1, 3, 3, 2, 0 ]
</Example>
</Description>
<Meth Name="GoodNodeSequences" Arg="e|H, mu"/>
<Returns>list of all good node sequences for <M>\mu</M></Returns>
<Description>
<Example>
gap&gt; H:=Specht(4);; GoodNodeSequences(H,5,2,1);
[ [ 0, 1, 2, 3, 3, 2, 0, 0 ], [ 0, 3, 1, 2, 2, 3, 0, 0 ],
  [ 0, 1, 3, 2, 2, 3, 0, 0 ], [ 0, 1, 2, 3, 3, 0, 2, 0 ],
  [ 0, 1, 2, 3, 0, 3, 2, 0 ], [ 0, 1, 2, 3, 3, 0, 0, 2 ],
  [ 0, 1, 2, 3, 0, 3, 0, 2 ] ]
</Example>
The good node sequences determine the Mullineux map (see
<Ref Oper="GoodNodes"/> and <Ref Oper="MullineuxMap"/>). This function
requires the package &specht; (see
<Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="PartitionGoodNodeSequence" Arg="e|H, gns"/>
<Returns>the unique <M>e</M>-regular partition corresponding to <M>gns</M>
(or <K>fail</K> if in fact <M>gns</M> is not a good node sequence).
</Returns>
<Description>
<Example>
gap&gt; H:=Specht(4);;
gap&gt; PartitionGoodNodeSequence(H,0, 3, 1, 0, 2, 2, 1, 3, 3, 2);
[ 4, 4, 2 ]
</Example>

See also <Ref Oper="GoodNodes"/>, <Ref Oper="GoodNodeSequence"/>
and <Ref Oper="MullineuxMap"/>. This function requires the package
&specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="GoodNodeLatticePath" Arg="e|H, mu"/>
<Returns>a sequence of partitions which give a path in the <M>e</M>-good
partition lattice from the empty partition to <M>\mu</M>.</Returns>
<Meth Name="GoodNodeLatticePaths" Arg="e|H, mu"/>
<Returns>the list of all paths in the <M>e</M>-good partition lattice which
end in <M>\mu</M>.</Returns>
<Meth Name="LatticePathGoodNodeSequence" Arg="e|H, gns"/>
<Returns>the path corresponding to a given good node sequence <M>gns</M>
</Returns>
<Description>
<Example>
gap&gt; GoodNodeLatticePath(3,3,2,1);
[ [ 1 ], [ 1, 1 ], [ 2, 1 ], [ 2, 1, 1 ], [ 2, 2, 1 ], [ 3, 2, 1 ] ]
gap&gt; GoodNodeLatticePaths(3,3,2,1);
[ [ [ 1 ], [ 1, 1 ], [ 2, 1 ], [ 2, 1, 1 ], [ 2, 2, 1 ], [ 3, 2, 1 ] ],
  [ [ 1 ], [ 1, 1 ], [ 2, 1 ], [ 2, 2 ], [ 2, 2, 1 ], [ 3, 2, 1 ] ] ]
gap&gt; GoodNodeSequence(4,6,3,2);
[ 0, 3, 1, 0, 2, 2, 3, 3, 0, 1, 1 ]
gap&gt; LatticePathGoodNodeSequence(4,last);
[ [ 1 ], [ 1, 1 ], [ 2, 1 ], [ 2, 2 ], [ 3, 2 ], [ 3, 2, 1 ], [ 4, 2, 1 ],
  [ 4, 2, 2 ], [ 5, 2, 2 ], [ 6, 2, 2 ], [ 6, 3, 2 ] ]
</Example>

See also <Ref Oper="GoodNodes"/>. This function requires the package
&specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="LittlewoodRichardsonRule" Arg="mu, nu"/>
<Meth Name="LittlewoodRichardsonCoefficient" Arg="mu, nu, tau"/>
<Description>
Given partitions <M>\mu</M> of <M>n</M> and <M>\nu</M> of <M>m</M> the
module <M>S(\mu)\otimes S(\nu)</M> is naturally an <M>H(S_n\times S_m)</M>-
module and, by inducing, we obtain an <M>H(S_{n+m})</M>-module. This module
has the same composition factors as <M>\sum_{\nu} a_{\mu\nu}^\lambda
S(\lambda)</M>,
where the sum runs over all partitions <M>\lambda</M> of <M>n+m</M> and the
integers <M>a_{\mu\nu}^\lambda</M> are the Littlewood-Richardson
coefficients. The integers <M>a_{\mu\nu}^\lambda</M> can be calculated using
a straightforward combinatorial algorithm known as the Littlewood-Richardson
rule (see <Cite Key="JK"/>).

The function <Ref Oper="LittlewoodRichardsonRule"/> returns an (unordered)
list of partitions of <M>n+m</M> in which each partition <M>\lambda</M>
occurs <M>a_{\mu\nu}^\lambda</M> times. The Littlewood-Richardson
coefficients are independent of <M>e</M>; they can be read more easily from
the computation <M>S(\mu)\otimes S(\nu)</M>.

<Example>
gap&gt; SizeScreen([80,20]);; H:=Specht(0);; # the generic Hecke algebra with 'R'=*C*['q']
gap&gt; LittlewoodRichardsonRule([3,2,1],[4,2]);
[ [ 4, 3, 2, 2, 1 ], [ 4, 3, 3, 1, 1 ], [ 4, 3, 3, 2 ], [ 4, 4, 2, 1, 1 ],
  [ 4, 4, 2, 2 ], [ 4, 4, 3, 1 ], [ 5, 2, 2, 2, 1 ], [ 5, 3, 2, 1, 1 ],
  [ 5, 3, 2, 2 ], [ 5, 4, 2, 1 ], [ 5, 3, 2, 1, 1 ], [ 5, 3, 3, 1 ],
  [ 5, 4, 1, 1, 1 ], [ 5, 4, 2, 1 ], [ 5, 5, 1, 1 ], [ 5, 3, 2, 2 ],
  [ 5, 3, 3, 1 ], [ 5, 4, 2, 1 ], [ 5, 4, 3 ], [ 5, 5, 2 ], [ 6, 2, 2, 1, 1 ],
  [ 6, 3, 1, 1, 1 ], [ 6, 3, 2, 1 ], [ 6, 4, 1, 1 ], [ 6, 2, 2, 2 ],
  [ 6, 3, 2, 1 ], [ 6, 4, 2 ], [ 6, 3, 2, 1 ], [ 6, 3, 3 ], [ 6, 4, 1, 1 ],
  [ 6, 4, 2 ], [ 6, 5, 1 ], [ 7, 2, 2, 1 ], [ 7, 3, 1, 1 ], [ 7, 3, 2 ],
  [ 7, 4, 1 ] ]
gap&gt; Display(MakeSpecht(H,3,2,1)*MakeSpecht(H,4,2));
S(7,4,1) + S(7,3,2) + S(7,3,1^2) + S(7,2^2,1) + S(6,5,1) + 2S(6,4,2) + 2S(6,4,\
1^2) + S(6,3^2) + 3S(6,3,2,1) + S(6,3,1^3) + S(6,2^3) + S(6,2^2,1^2) + S(5^2,2\
) + S(5^2,1^2) + S(5,4,3) + 3S(5,4,2,1) + S(5,4,1^3) + 2S(5,3^2,1) + 2S(5,3,2^\
2) + 2S(5,3,2,1^2) + S(5,2^3,1) + S(4^2,3,1) + S(4^2,2^2) + S(4^2,2,1^2) + S(4\
,3^2,2) + S(4,3^2,1^2) + S(4,3,2^2,1)
gap&gt; LittlewoodRichardsonCoefficient([3,2,1],[4,2],[5,4,2,1]);
3
</Example>

The function <Ref Oper="LittlewoodRichardsonCoefficient"/> returns a single
Littlewood-Richardson coefficient (although you are really better off
asking for all of them, since they will all be calculated anyway).<P/>

See also <Ref Oper="RInducedModule"/> and
<Ref Oper="InverseLittlewoodRichardsonRule"/>. This function requires the
package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="InverseLittlewoodRichardsonRule" Arg="tau"/>
<Returns>a list of all pairs of partitions <M>[\mu,\nu]</M> such that the
Littlewood-Richardson coefficient <M>a_{\mu\nu}^\tau</M> is non-zero
(see <Ref Oper="LittlewoodRichardsonRule"/>). The list returned is unordered
and <M>[\mu,\nu]</M> will appear <M>a_{\mu\nu}^\tau</M> times in it.
</Returns>
<Description>
<Example>
gap&gt; SizeScreen([80,20]);; InverseLittlewoodRichardsonRule(3,2,1);
[ [ [  ], [ 3, 2, 1 ] ], [ [ 1 ], [ 3, 2 ] ], [ [ 1 ], [ 2, 2, 1 ] ],
  [ [ 1 ], [ 3, 1, 1 ] ], [ [ 1, 1 ], [ 2, 2 ] ], [ [ 1, 1 ], [ 3, 1 ] ],
  [ [ 1, 1 ], [ 2, 1, 1 ] ], [ [ 1, 1, 1 ], [ 2, 1 ] ], [ [ 2 ], [ 2, 2 ] ],
  [ [ 2 ], [ 3, 1 ] ], [ [ 2 ], [ 2, 1, 1 ] ], [ [ 2, 1 ], [ 3 ] ],
  [ [ 2, 1 ], [ 2, 1 ] ], [ [ 2, 1 ], [ 2, 1 ] ], [ [ 2, 1 ], [ 1, 1, 1 ] ],
  [ [ 2, 1, 1 ], [ 2 ] ], [ [ 2, 1, 1 ], [ 1, 1 ] ], [ [ 2, 2 ], [ 2 ] ],
  [ [ 2, 2 ], [ 1, 1 ] ], [ [ 2, 2, 1 ], [ 1 ] ], [ [ 3 ], [ 2, 1 ] ],
  [ [ 3, 1 ], [ 2 ] ], [ [ 3, 1 ], [ 1, 1 ] ], [ [ 3, 1, 1 ], [ 1 ] ],
  [ [ 3, 2 ], [ 1 ] ], [ [ 3, 2, 1 ], [  ] ] ]
</Example>

See also <Ref Oper="LittlewoodRichardsonRule"/>. This function requires the
package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="EResidueDiagram" Arg="H|e, mu"/>
<Meth Name="EResidueDiagram" Label="for modules" Arg="x"/>
<Description>
The <M>e</M>-residue of the <M>(i,j)</M>-th node in the diagram of a
partition <M>\mu</M> is <M>(j-i)\bmod e</M>$. <C>EResidueDiagram(</C><M>e,
\mu</M><C>)</C> prints the diagram of the partition <M>\mu</M> replacing
each node with its <M>e</M>-residue.

If <M>x</M> is a module then <C>EResidueDiagram(</C><M>x</M><C>)</C> prints
the <M>e</M>-residue diagrams of all of the <M>e</M>-regular partitions
appearing in <M>x</M> (such diagrams are useful when trying to decide how to
restrict and induce modules and also in applying results such as the
<Q>Scattering theorem</Q> of <Cite Key="JM1"/>). It is not necessary to
supply the integer <M>e</M> in this case because <M>x</M> <Q>knows</Q> the
value of <M>e</M>.

<Example>
gap&gt; H:=Specht(2);; EResidueDiagram(MakeSpecht(MakePIM(H,7,5)));
[ 7, 5 ]
   0   1   0   1   0   1   0
   1   0   1   0   1
[ 6, 5, 1 ]
   0   1   0   1   0   1
   1   0   1   0   1
   0
[ 5, 4, 2, 1 ]
   0   1   0   1   0
   1   0   1   0
   0   1
   1
# There are 3 2-regular partitions.
true
</Example>

This function requires the package &specht;
(see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="HookLengthDiagram" Arg="mu"/>
<Description>
Prints the diagram of <M>\mu</M>, replacing each node with its hook length
(see <Cite Key="JK"/>).

<Example>
gap&gt; HookLengthDiagram(11,6,3,2);
  14  13  11   9   8   7   5   4   3   2   1
   8   7   5   3   2   1
   4   3   1
   2   1
true
</Example>

This function requires the package &specht;
(see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="RemoveRimHook" Arg="mu, row, col"/>
<Returns>the partition obtained from <M>\mu</M> by removing the
<M>(row, col)</M>-th rim hook from (the diagram of) <M>\mu</M>.</Returns>
<Description>
<Example>
gap&gt; RemoveRimHook([6,5,4],1,2);
[ 4, 3, 1 ]
gap&gt; RemoveRimHook([6,5,4],2,3);
[ 6, 3, 2 ]
gap&gt; HookLengthDiagram(6,5,4);
   8   7   6   5   3   1
   6   5   4   3   1
   4   3   2   1
true
</Example>

See also <Ref Oper="AddRimHook"/>. This function requires the package
&specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="AddRimHook" Arg="mu, r, h"/>
<Returns>a list <M>[\nu, l]</M> where <M>\nu</M> is the partition obtained
from <M>\mu</M> by adding a rim hook of length <M>h</M> with its <Q>foot</Q>
in the <M>r</M>-th row of (the diagram of) <M>\mu</M> and <M>l</M> is the
leg length of the wrapped on rim hook (see, for example, <Cite Key="JK"/>).
If the resulting diagram <M>\nu</M> is not the diagram of a partition then
<K>fail</K> is returned.</Returns>
<Description>
<Example>
gap&gt; AddRimHook([6,4,3],1,3);
[ [ 9, 4, 3 ], 0 ]
gap&gt; AddRimHook([6,4,3],2,3);
fail
gap&gt; AddRimHook([6,4,3],3,3);
[ [ 6, 5, 5 ], 1 ]
gap&gt; AddRimHook([6,4,3],4,3);
[ [ 6, 4, 3, 3 ], 0 ]
gap&gt; AddRimHook([6,4,3],5,3);
fail
</Example>

See also <Ref Oper="RemoveRimHook"/>. This function requires the
package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
</Section>
<!--######################################################################-->
<Section>
<Heading>Operations on partitions</Heading>
This section contains functions for manipulating partitions and
also several useful orderings on the set of partitions.
<!--######################################################################-->
<ManSection>
<Meth Name="ECore" Arg=""/>
<Returns></Returns>
<Description>
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="IsECore" Arg=""/>
<Returns></Returns>
<Description>
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="EQuotient" Arg=""/>
<Returns></Returns>
<Description>
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="CombineEQuotientECore" Arg=""/>
<Returns></Returns>
<Description>
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="EWeight" Arg=""/>
<Returns></Returns>
<Description>
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="ERegularPartitions" Arg=""/>
<Returns></Returns>
<Description>
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="IsERegular" Arg=""/>
<Returns></Returns>
<Description>
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="ConjugatePartition" Arg=""/>
<Returns></Returns>
<Description>
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="BetaSet" Arg=""/>
<Returns></Returns>
<Description>
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="PartitionBetaSet" Arg=""/>
<Returns></Returns>
<Description>
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="ETopLadder" Arg=""/>
<Returns></Returns>
<Description>
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="Dominates" Arg=""/>
<Returns></Returns>
<Description>
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="LengthLexicographic" Arg=""/>
<Returns></Returns>
<Description>
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="Lexicographic" Arg=""/>
<Returns></Returns>
<Description>
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="ReverseDominance" Arg=""/>
<Returns></Returns>
<Description>
</Description>
</ManSection>
</Section>
<!--######################################################################-->
<Section>
<Heading>Miscellaneous functions on modules</Heading>
This section contains some functions for looking at the partitions in a
given module for the Hecke algebras. Most of them are used internally by
&Specht;.
<!--######################################################################-->
<ManSection>
<Meth Name="Specialized" Arg="x[, q]"/>
<Meth Name="Specialized" Label="for a decomposition matrix" Arg="d[, q]"/>
<Returns>the corresponding element of the Grothendieck ring or the
corresponding decomposition matrix of the Hecke algebra when given
an element of the Fock space <M>x</M> (see <Ref Oper="Specht"/>), or a
crystallized decomposition matrix (see
<Ref Oper="CrystalDecompositionMatrix"/>), respectively. </Returns>
<Description>
By default the indeterminate <M>v</M> is specialized to <M>1</M>; however
<M>v</M> can be specialized to any (integer) <M>q</M> by supplying a second
argument.

<Example>
gap&gt; SizeScreen([80,20]);; H:=Specht(2);; x:=MakeFockPIM(H,6,2);; Display(x);
Sq(6,2) + vSq(6,1^2) + vSq(5,3) + v^2Sq(5,1^3) + vSq(4,3,1) + v^2Sq(4,2^2) + (\
v^3+v)Sq(4,2,1^2) + v^2Sq(4,1^4) + v^2Sq(3^2,1^2) + v^3Sq(3,2^2,1) + v^3Sq(3,1\
^5) + v^3Sq(2^3,1^2) + v^4Sq(2^2,1^4)
gap&gt; Display(Specialized(x));
S(6,2) + S(6,1^2) + S(5,3) + S(5,1^3) + S(4,3,1) + S(4,2^2) + 2S(4,2,1^2) + S(\
4,1^4) + S(3^2,1^2) + S(3,2^2,1) + S(3,1^5) + S(2^3,1^2) + S(2^2,1^4)
gap&gt; Display(Specialized(x,2));
S(6,2) + 2S(6,1^2) + 2S(5,3) + 4S(5,1^3) + 2S(4,3,1) + 4S(4,2^2) + 10S(4,2,1^2\
) + 4S(4,1^4) + 4S(3^2,1^2) + 8S(3,2^2,1) + 8S(3,1^5) + 8S(2^3,1^2) + 16S(2^2,\
1^4)
</Example>

An example of <Ref Oper="Specialized"/> being applied to a crystallized
decomposition matrix can be found in
<Ref Oper="CrystalDecompositionMatrix"/>. This function requires the package &specht;
(see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="ERegulars" Arg="x"/>
<Meth Name="ERegulars" Label="for a decomposition matrix" Arg="d"/>
<Meth Name="ListERegulars" Arg="x"/>
<Description>
<C>ERegulars(</C><M>x</M><C>)</C> prints a list of the <M>e</M>-regular
partitions, together with multiplicities, which occur in the module
<M>x</M>. <C>ListERegulars(</C><M>x</M><C>)</C>
returns an actual list of these partitions rather than printing them.

<Example>
gap&gt; H:=Specht(8);;
gap&gt; x:=MakeSpecht(RInducedModule(MakePIM(H,8,5,3)));; Display(x);
S(9,5,3) + S(8,6,3) + S(8,5,4) + S(8,5,3,1) + S(6,5,3^2) + S(5^2,4,3) + S(5^2,3^2,1)
gap&gt; ERegulars(x);
[ 9, 5, 3 ]  [ 8, 6, 3 ]  [ 8, 5, 4 ]  [ 8, 5, 3, 1 ]
[ 6, 5, 3, 3 ]  [ 5, 5, 4, 3 ]  [ 5, 5, 3, 3, 1 ]
gap&gt; Display(MakePIM(x));
P(9,5,3) + P(8,6,3) + P(8,5,4) + P(8,5,3,1)
</Example>

This example shows why these functions are useful: given a projective
module <M>x</M>, as aboveand the list of <M>e</M>-regular partitions in
<M>x</M> we know the possible indecomposable direct summands of <M>x</M>.<P/>

Note that it is not necessary to specify what <M>e</M> is when calling this
function because <M>x</M> <Q>knows</Q> the value of <M>e</M>.<P/>

The function <Ref Oper="ERegulars"/> can also be applied to a decomposition
matrix <M>d</M>; in this case it returns the unitriangular submatrix of
<M>d</M> whose rows and columns are indexed by the <M>e</M>-regular
partitions.<P/>

These function requires the package &specht;
(see <Ref Func="LoadPackage" BookName="Reference"/>).

</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="SplitECores" Arg="x"/>
<Returns>a list <M>[b_1,\ldots,b_k]</M> where the Specht modules in each
<M>b_i</M> all belong to the same block (i.e. they have the same
<M>e</M>-core).</Returns>
<Meth Name="SplitECores" Label="for a module and a partition" Arg="x, mu"/>
<Returns>the component of <M>x</M> which is in the same block as <M>\mu</M>.
</Returns>
<Meth Name="SplitECores" Label="for two modules" Arg="x, y"/>
<Returns>the component of <M>x</M> which is in the same block as <M>y</M>.
</Returns>
<Description>
<Example>
gap&gt; H:=Specht(2);;
gap&gt; Display(SplitECores(RInducedModule(MakeSpecht(H,5,3,1))));
[ S(6,3,1) + S(5,3,2) + S(5,3,1,1), S(5,4,1) ]
gap&gt; Display(RInducedModule(MakeSpecht(H,5,3,1),0));
S(5,4,1)
gap&gt; Display(RInducedModule(MakeSpecht(H,5,3,1),1));
S(6,3,1) + S(5,3,2) + S(5,3,1^2)
</Example>

See also <Ref Oper="ECore"/>, <Ref Oper="RInducedModule"/> and
<Ref Oper="RRestrictedModule"/>. This function requires the package &specht;
(see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="Coefficient" Arg="x, mu"/>
<Returns>the coefficient of <M>S(\mu)</M> in <M>x</M>
(resp.  <M>D(\mu)</M>, or <M>P(\mu)</M>).</Returns>
<Description>
<Example>
gap&gt; H:=Specht(3);; x:=MakeSpecht(MakePIM(H,7,3));; Display(x);
S(7,3) + S(7,2,1) + S(6,2,1^2) + S(5^2) + S(5,2^2,1) + S(4^2,1^2) + S(4,3^2) + S(4,3,2,1)
gap&gt; Coefficient(x,5,2,2,1);
1
</Example>

This function requires the package &specht;
(see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="InnerProduct" Arg="x, y"/>
<Description>
Here <M>x</M> and <M>y</M> are some modules of the Hecke algebra
(i.e. Specht modules, PIMS, or simple modules). <Ref Oper="InnerProduct"/>
computes the standard inner product of these elements. This is sometimes a
convenient way to compute decomposition numbers (for example).

<Example>
gap&gt; H:=Specht(2);; InnerProduct(MakeSpecht(H,2,2,2,1), MakePIM(H,4,3));
1
gap&gt; DecompositionNumber(H,[2,2,2,1],[4,3]);
1
</Example>

This function requires the package &specht;
(see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
</Section>
<!--######################################################################-->
<Section>
<Heading>Semi-standard and standard tableaux</Heading>
These functions are not really part of &Specht; proper; however they are
related and may well be of use to someone. Tableaux are represented
by objects, that can be constructed from a list of lists.
<!--######################################################################-->
<ManSection>
<Meth Name="Tableau" Arg="tab"/>
<Returns>tableau object corresponding to the given list of lists</Returns>
<Description>
This is the constructor for tableau objects. The first entry of the given
argument list is the list corresponding to the first row of the tableau.
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="SemiStandardTableaux" Arg="mu, nu"/>
<Returns>list of the semistandard <M>\mu</M>-tableaux of type <M>\nu</M>
<Cite Key="JK"/></Returns>
<Description>
<M>\mu</M> a partition, <M>\nu</M> a composition.
<Example>
gap&gt; SizeScreen([80,20]);; Display(SemiStandardTableaux([4,3],[1,1,1,2,2]));
[ Tableau( [ [ 1, 2, 3, 4 ], [ 4, 5, 5 ] ] ), Tableau( [ [ 1, 2, 3, 5 ], [ 4, 4, 5 ] ] ),
  Tableau( [ [ 1, 2, 4, 4 ], [ 3, 5, 5 ] ] ), Tableau( [ [ 1, 2, 4, 5 ], [ 3, 4, 5 ] ] ),
  Tableau( [ [ 1, 3, 4, 4 ], [ 2, 5, 5 ] ] ), Tableau( [ [ 1, 3, 4, 5 ], [ 2, 4, 5 ] ] ) ]
</Example>
See also <Ref Oper="StandardTableaux"/>. This function requires the package
&specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="StandardTableaux" Arg="mu"/>
<Returns>list of the standard <M>\mu</M>-tableaux</Returns>
<Description>
<M>\mu</M> a partition
<Example>
gap&gt; SizeScreen([80,20]);; Display(StandardTableaux(4,2));
[ Tableau( [ [ 1, 2, 3, 4 ], [ 5, 6 ] ] ), Tableau( [ [ 1, 2, 3, 5 ], [ 4, 6 ] ] ),
  Tableau( [ [ 1, 2, 3, 6 ], [ 4, 5 ] ] ), Tableau( [ [ 1, 2, 4, 5 ], [ 3, 6 ] ] ),
  Tableau( [ [ 1, 2, 4, 6 ], [ 3, 5 ] ] ), Tableau( [ [ 1, 2, 5, 6 ], [ 3, 4 ] ] ),
  Tableau( [ [ 1, 3, 4, 5 ], [ 2, 6 ] ] ), Tableau( [ [ 1, 3, 4, 6 ], [ 2, 5 ] ] ),
  Tableau( [ [ 1, 3, 5, 6 ], [ 2, 4 ] ] ) ]
</Example>
See also <Ref Oper="SemiStandardTableaux"/>. This function requires the package
&specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="ConjugatTableau" Arg="tab"/>
<Returns>tableau obtained from <M>tab</M> by interchangings its rows and
columns</Returns>
<Description>
<Example>
gap&gt; Display(ConjugateTableau(Tableau([ [ 1, 3, 5, 6 ], [ 2, 4 ] ])));
Standard Tableau:
1	2
3	4
5
6
</Example>
This function requires the package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="ShapeTableau" Arg="tab"/>
<Returns>the partition (or composition) obtained from <M>tab</M></Returns>
<Description>
<Example>
gap&gt; ShapeTableau( Tableau([ [ 1, 1, 2, 3 ], [ 4, 5 ] ]) );
[ 4, 2 ]
</Example>
This function requires the package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="TypeTableau" Arg="tab"/>
<Returns>the type of the (semistandard) tableau <M>tab</M></Returns>
<Description>
The type of a tableau is, the composition <M>\sigma=
(\sigma_1,\sigma_2,\ldots)</M> where <M>\sigma_i</M> is
the number of entries in <M>tab</M> which are equal to <M>i</M>.
<Example>
gap&gt; List(SemiStandardTableaux([5,4,2],[4,3,0,1,3]),TypeTableau);
[ [ 4, 3, 0, 1, 3 ], [ 4, 3, 0, 1, 3 ], [ 4, 3, 0, 1, 3 ], [ 4, 3, 0, 1, 3 ], [ 4, 3, 0, 1, 3 ] ]
</Example>
This function requires the package &specht;
(see <Ref Func="LoadPackage" BookName="Reference" BookName="Reference"/>).
</Description>
</ManSection>
</Section>
</Chapter>

