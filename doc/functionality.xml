<!--

      functionality.xml            specht package documentation
                                                                Dmitriy Traytel

         Copyright (C) 2010, Dmitriy Traytel

This chapter gives examples for the usage of this package.

-->

<Chapter Label="functionality">
<Heading>Specht functionality</Heading>

<Section>
<Heading>Structural design</Heading>
The stucture...
</Section>

<Section>
<Heading>Specht functions</Heading>

<ManSection>
<Meth Name="Specht" Label="for an integer" Arg="e"/>
<Meth Name="Specht" Label="for two integers" Arg="e, p"/>
<Meth Name="Specht" Label="for to integers and a valuation map"
  Arg="e, p, val"/>
<Meth Name="Specht" Arg="e, p, val, ring"/>
<Returns>object belonging to the filter <Ref Filt="IsHecke"/></Returns>
<Description>
Let <M>R</M> be a field of characteristic <M>0</M>, <M>q</M> a non-zero
element of <M>R</M>, and let <M>e</M> be the smallest positive integer
such that <M>1+q+\ldots+q^{e-1}=0</M>
(we set <M>e=0</M> if no such integer exists). The record returned
by <C>Specht(e)</C> allows calculations in the Grothendieck rings of
the Hecke algebras <M>H</M> of type <E>A</E> which are defined over
<M>R</M> and have parameter <M>q</M>. (The Hecke algebra is described in
Chapter <Q>Iwahori-Hecke algebras</Q>; see also <Q>Hecke</Q>.) Below we
also describe how to consider Hecke algebras defined over fields of
positive characteristic.<P/>

<Ref Oper="Specht"/> returns an object which contains information about the
the family of Hecke algebras determined by <M>R</M> and <M>q</M>.
This object needs to be passed to the most of the &Specht; functions as
argument.<P/>

<Example>
gap&gt; H:=Specht(5);
&lt;Hecke algebra with e = 5&gt;
gap&gt; Display(last);
Specht(e=5, S(), P(), D())
gap&gt; IsZeroCharacteristic(last);
true
</Example>

There is also a method <Ref Oper="Schur"/> for doing calculations with
the <M>q</M>-Schur algebra. See <Ref Oper="DecompositionMatrix"/>,
and <Ref Oper="CrystalDecompositionMatrix"/>.<P/>

This function requires the package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
<!-- TODO -->
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="Schur" Label="for an integer" Arg="e"/>
<Meth Name="Schur" Label="for two integers" Arg="e, p"/>
<Meth Name="Schur" Label="for to integers and a valuation map"
  Arg="e, p, val"/>
<Meth Name="Schur" Arg="e, p, val, ring"/>
<Returns>object belonging to the filter <Ref Filt="IsSchur"/></Returns>
<Description>
This function behaves almost identically to the function
<Ref Oper="Specht"/>, the only difference being that the belonging modules
are printed as <Q>W</Q>, <Q>P</Q>, <Q>F</Q> and that they correspond to the
<M>q</M>-Weyl modules, the projective decomposable modules, and the simple
modules of the <M>q</M>-Schur algebra respectively. Note that our labeling
of these modules is non-standard, following that used by James in
<Cite Key="J"/>. The standard labeling can be obtained from ours by
replacing all partitions by their conjugates.<P/>

Almost all of the functions in &Specht; which accept a Hecke algebra object
<M>H</M> will also accept the object <M>S</M> returned by <Ref Oper="Schur"/>
.<P/>

In the current version of &Specht; the decomposition matrices of <M>q</M>
-Schur algebras are not fully supported. The <Ref Oper=
"InducedDecompositionMatrix"/> function can be applied to these matrices;
however there are no additional routines available for calculating the
columns corresponding to <M>e</M>-singular partitions. The decomposition
matrices for the <M>q</M>-Schur algebras defined over a field of
characteristic <M>0</M> for <M>n\leq 10</M> are in the &Specht; libraries.

<Example>
gap&gt; S:=Schur(2);
&lt;Schur algebra with e = 2&gt;
gap&gt; InducedDecompositionMatrix(DecompositionMatrix(S,3));
# The following projectives are missing from &lt;d&gt;:
#  [ 2, 2 ]
&lt;5x5 decomposition matrix&gt;
gap&gt; Display(last);
4    | 1                   # DecompositionMatrix(S,4) returns the
3,1  | 1 1                 # full decomposition matrix. The point
2^2  | . 1 .               # of this example is to emphasize the
2,1^2| 1 1 . 1             # current limitations of Schur.
1^4  | 1 . . 1 1
</Example>

Note that when <M>S</M> is defined over a field of characteristic zero then
the functions <Ref Oper="MakeFockWeyl"/> and <Ref Oper="MakeFockPIM"/> will
calculate the canonical basis elements (see <Ref Oper="Specht"/>);
currently <C>MakeFockPIM(</C><M>\mu</M><C>)</C> is implemented only for
<M>e</M>-regular partitions.<P/>

See also <Ref Oper="Specht"/>.
This function requires the package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="DecompositionMatrix" Label="for an algebra and an integer"
  Arg="H, n[, Ordering]"/>
<Meth Name="DecompositionMatrix" Arg="H, file[, Ordering]"/>
<Returns> the decomposition matrix <M>D</M> of <M>H(S_n)</M> where <M>H</M>
is a Hecke algebra object returned by the function <Ref Oper="Specht"/>
(or <Ref Oper="Schur"/> ).</Returns>
<Description>
<Ref Oper="DecompositionMatrix"/> first checks whether the required
decomposition matrix exists as a library file (checking first in the current
directory, next in the directory specified by <Ref Var="SpechtDirectory"/>,
and finally in the &Specht; libraries). If the base field
of <M>H</M> has characteristic zero, <Ref Oper="DecompositionMatrix"/>
next looks for <E>crystallized decomposition matrices</E> (see
<Ref Oper="CrystalDecompositionMatrix"/>). If the decomposition matrix
<M>d</M> is not stored in the library <Ref Oper="DecompositionMatrix"/> will
calculate <M>d</M> when <M>H</M> is a Hecke algebra with a
base field of characteristic zero, and will return <C>fail</C> otherwise
(in which case the function <Ref Oper="CalculateDecompositionMatrix"/>
can be used to force &Specht; to try and
calculate this matrix).<P/>

For Hecke algebras defined over fields of characteristic zero, &Specht;
uses the algorithm of <Cite Key="LLT"/> to calculate decomposition matrices
The decomposition matrices for the <M>q</M>-Schur algebras for <M>n\leq10</M>
are contained in the &Specht; library, as are those for the symmetric group
over fields of positive characteristic when <M>n&lt;15</M>.<P/>

Once a decomposition matrix is known, &Specht; keeps an internal copy
of it which is used by the functions <Ref Oper="MakeSpecht"/>,
<Ref Oper="MakePIM"/>, and <Ref Oper="MakeSimple"/>; these
functions also read decomposition matrix files as needed.<P/>

If you set the variable <Ref Var="SpechtDirectory"/>, then &Specht; will also
search for decomposition matrix files in this directory. The files in the
current directory override those in <Ref Var="SpechtDirectory"/> and those in
the &Specht; libraries.<P/>

In the second form of the function, when a <M>filename</M> is supplied,
<Ref Oper="DecompositionMatrix"/> will read the decomposition matrix in the
file <M>filename</M>, and this matrix will become &Specht;'s internal copy of
this matrix.<P/>

By default, the rows and columns of the decomposition matrices are ordered
<Ref Oper="DecompositionMatrix"/> with an ordering function such as
<Ref Oper="LengthLexicographic"/> or <Ref Oper="ReverseDominance"/>. You do
not need to specify the ordering you want every time you call
<Ref Oper="DecompositionMatrix"/>; &Specht; will keep the same
ordering until you change it again. This ordering can also be set <Q>by
hand</Q> using the operation <Ref Oper="SetOrdering"/>

<Example>
gap&gt; DecompositionMatrix(Specht(3),6,LengthLexicographic);
&lt;11x7 decomposition matrix&gt;
gap&gt; Display(last);
6      | 1
5,1    | 1 1
4,2    | . . 1
3^2    | . 1 . 1
4,1^2  | . 1 . . 1
3,2,1  | 1 1 . 1 1 1
2^3    | 1 . . . . 1
3,1^3  | . . . . 1 1
2^2,1^2| . . . . . . 1
2,1^4  | . . . 1 . 1 .
1^6    | . . . 1 . . .
</Example>

Once you have a decomposition matrix it is often nice to be able
to print it. The on screen version is often good enough; <!--there is also
a 'TeX' command  which generates a \LaTeX\ version.--> There are also
functions for converting &Specht; decomposition matrices into &GAP;
matrices and visa versa (see <Ref Oper="MatrixDecompositionMatrix"/>
and <Ref Oper="DecompositionMatrixMatrix"/>).<P/>

Using the function <Ref Oper="InducedDecompositionMatrix"/>, it is possible
to induce a decomposition matrix. See also
<Ref Oper="SaveDecompositionMatrix"/> and
<Ref Oper="IsNewIndecomposable"/>, <Ref Oper="Specht"/>, <Ref Oper="Schur"/>,
and <Ref Oper="CrystalDecompositionMatrix"/>. This function requires the
package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="CrystalDecompositionMatrix" Arg="H, n[, Ordering]"/>
<Meth Name="CrystalDecompositionMatrix" Label="for an algebra and a filename"
  Arg="H, file[, Ordering]"/>
<Returns> the crystal decomposition matrix <M>D</M> of <M>H(S_n)</M> where
<M>H</M> is a Hecke algebra object returned by the function
<Ref Oper="Specht"/> (or <Ref Oper="Schur"/> ).</Returns>
<Description>
This function is similar to <Ref Oper="DecompositionMatrix"/>. The columns
of decomposition matrices correspond to projective indecomposables; the
columns of crystallized decomposition matrices correspond to the canonical
basis elements of the Fock space (see
<Ref Oper="Specht" Label="for an integer"/>). Consequently,
the entries in these matrices are polynomials (in <M>v</M>), and by
specializing (i.e. setting <M>v</M> equal to <M>1</M>; see
<Ref Oper="Specialized"/>), the decomposition matrices of <M>H</M>
are obtained (see <Ref Oper="Specht"/>).

Crystallized decomposition matrices are defined only for Hecke algebras
over a base field of characteristic zero. Unlike <Q>normal</Q>
decomposition matrices, crystallized decomposition matrices cannot be
induced.

<Example>
gap&gt; CrystalDecompositionMatrix(Specht(3), 6);
&lt;11x7 decomposition matrix&gt;
gap&gt; Display(last);
6      |   1
5,1    |   v   1
4,2    |   .   .   1
4,1^2  |   .   v   .   1
3^2    |   .   v   .   .   1
3,2,1  |   v v^2   .   v   v   1
3,1^3  |   .   .   . v^2   .   v
2^3    | v^2   .   .   .   .   v
2^2,1^2|   .   .   .   .   .   .   1
2,1^4  |   .   .   .   .   v v^2   .
1^6    |   .   .   .   . v^2   .   .
gap&gt; Specialized(last);   # set v equal to 1.
&lt;11x7 decomposition matrix&gt;
gap&gt; Display(last);
6      | 1
5,1    | 1 1
4,2    | . . 1
4,1^2  | . 1 . 1
3^2    | . 1 . . 1
3,2,1  | 1 1 . 1 1 1
3,1^3  | . . . 1 . 1
2^3    | 1 . . . . 1
2^2,1^2| . . . . . . 1
2,1^4  | . . . . 1 1 .
1^6    | . . . . 1 . .
</Example>

See also <Ref Oper="Specht"/>, <Ref Oper="Schur"/>,
<Ref Oper="DecompositionMatrix"/> and <Ref Oper="Specialized"/>. This
function requires the package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection Label="DecompositionNumber">
<Meth Name="DecompositionNumber" Arg="H, mu, nu"/>
<Meth Name="DecompositionNumber" Label="for a decomposition matrix"
  Arg="d, mu, nu"/>
<Description>
This function attempts to calculate the decomposition multiplicity of
<M>D(\nu)</M> in <M>S(\mu)</M> (equivalently, the multiplicity of
<M>S(\mu)</M> in <M>P(\nu)</M>). If <M>P(\nu)</M> is known, we just look up
the answer; if not <Ref Oper="DecompositionNumber"/> tries to calculate the
answer using <Q>row and column removal</Q> (see
<Cite Key="J" Where="Theorem 6.18"/>).<P/>

<Example>
gap&gt; H:=Specht(6);; DecompositionNumber(H,[6,4,2],[6,6]);
0
</Example>

This function requires the package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<Subsection Label="partitions">
<Heading>Partitions in &Specht;</Heading>
Many of the functions in &Specht; take partitions as arguments.
Partitions are usually represented by lists in &GAP;. In &Specht;,
all the functions which expect a partition will accept their argument
either as a list or simply as a sequence of numbers. So, for example:

<Example>
gap&gt; H:=Specht(4);; Print(MakeSpecht(MakePIM(H,6,4)),"\n");
S(6,4)+S(6,3,1)+S(5,3,1,1)+S(3,3,2,1,1)+S(2,2,2,2,2)
gap&gt; Print(MakeSpecht(MakePIM(H,[6,4])),"\n");
S(6,4)+S(6,3,1)+S(5,3,1,1)+S(3,3,2,1,1)+S(2,2,2,2,2)
</Example>

Some functions require more than one argument, but the convention still
applies.

<Example>
gap&gt; ECore(3, [6,4,2]);
[ 6, 4, 2 ]
gap&gt; ECore(3, 6,4,2);
[ 6, 4, 2 ]
gap&gt; GoodNodes(3, 6,4,2);
[ false, false, 3 ]
gap&gt; GoodNodes(3, [6,4,2], 2);
3
</Example>

Basically, it never hurts to put the extra brackets in, and they can
be omitted so long as this is not ambiguous. One function where the
brackets are needed is <Ref Oper="DecompositionNumber"/> this is clear
because the function takes two partitions as its arguments.
</Subsection>
<Subsection Label="induce">
<Heading>Inducing and restricting modules</Heading>
&Specht; provides four functions <Ref Oper="RInducedModule"/>,
<Ref Oper="RRestrictedModule"/>, <Ref Oper="SInducedModule"/>
and <Ref Oper="SRestrictedModule"/> for inducing and restricting
modules. All functions can be applied to Specht modules, PIMs, and simple
modules. These functions all work by first rewriting all modules as a
linear combination of Specht modules (or <M>q</M>-Weyl modules), and then
inducing and restricting. Whenever possible the induced or restricted
module will be written in the original basis.<P/>

All of these functions can also be applied to elements of the Fock
space (see <Ref Oper="Specht"/>); in which case they correspond to the action
of the generators <M>E_i</M> and <M>F_i</M> of <M>U_q(\widehat{sl_e})</M> on
<M>\mathcal{F}</M>. There is also a function
<Ref Oper="InducedDecompositionMatrix"/> for inducing decomposition matrices.
</Subsection>
<!--######################################################################-->
<ManSection>
<Meth Name="RInducedModule" Arg="x"/>
<Meth Name="RInducedModule" Label="for residues"
  Arg="x r1[, r2, ...]"/>
<Returns>the induced modules of the Specht
modules, principal indecomposable modules, and simple modules (more
accurately, their image in the Grothendieck ring).</Returns>
<Description>
There is an natural embedding of <M>H(S_n)</M> in <M>H(S_{n+1})</M>
which in the usual way lets us define an <E>induced</E>
<M>H(S_{n+1})</M>-module for every <M>H(S_n)</M>-module.<P/>

There is also a function <Ref Oper="SInducedModule"/> which
provides a much faster way of <M>r</M>-inducing <M>s</M> times (and inducing
<M>s</M> times).<P/>

Let <M>\mu</M> be a partition. Then the induced module
<C>RInducedModule(S(</C><M>\mu</M><C>))</C> is easy to describe: it has the
same composition factors as <M>\sum S(\nu)</M>
where <M>\nu</M> runs over all partitions whose diagrams can be obtained by
adding a single node to the diagram of <M>\mu</M>.

<Example>
gap&gt; H:=Specht(2,2);;
gap&gt; Display(RInducedModule(MakeSpecht(H,7,4,3,1)));
S(8,4,3,1)+S(7,5,3,1)+S(7,4^2,1)+S(7,4,3,2)+S(7,4,3,1^2)
gap&gt; Display(RInducedModule(MakePIM(H,5,3,1)));
P(6,3,1)+2P(5,4,1)+P(5,3,2)
gap&gt; Display(RInducedModule(MakeSimple(H,11,2,1)));
# D(&lt;x&gt;), unable to rewrite &lt;x&gt; as a sum of simples
S(12,2,1)+S(11,3,1)+S(11,2^2)+S(11,2,1^2)
</Example>

When inducing indecomposable modules and simple modules,
<Ref Oper="RInducedModule"/> first rewrites these modules as a linear
combination of Specht modules (using known decomposition matrices), and then
induces this linear combination of Specht modules. If possible &Specht; then
rewrites the induced module back in the original basis. Note that in the last
example above, the decomposition matrix for <M>S_{15}</M> is not known by
&Specht; this is why <Ref Oper="RInducedModule"/> was unable to rewrite this
module in the <M>D</M>-basis.<P/>

<E><M>r</M>-Induction</E><P/>

Two Specht modules <M>S(\mu)</M> and <M>S(\nu)</M> belong to the same block
if and only if the corresponding partitions <M>\mu</M> and <M>\nu</M> have
the same <M>e</M>-core <Cite Key="JM2"/>  (see <Ref Oper="ECore"/>). Because
the <M>e</M>-core of a partition is determined by its (multiset of) <M>e</M>
-residues, if <M>S(\mu)</M> and <M>S(\nu)</M> appear in
<C>RInducedModule(S(</C><M>\tau</M><C>))</C>, for some partition
<M>\tau</M>, then <M>S(\mu)</M> and <M>S(nu)</M> belong to the same block if
and only if <M>\mu</M> and <M>\nu</M> can be obtained by adding a node of the
same <M>e</M>-residue to the diagram of <M>\tau</M>. The second form of
<Ref Oper="RInducedModule"/> allows one to induce <Q>within blocks</Q> by
only adding nodes of some fixed <M>e</M>-residue <M>r</M>; this is known as
<E>r-induction</E>. Note that <M>0\leq r&lt;e</M>.<P/>

<Example>
gap&gt; H:=Specht(4);; Display(RInducedModule(MakeSpecht(H,5,2,1)));
S(6,2,1)+S(5,3,1)+S(5,2^2)+S(5,2,1^2)
gap&gt; Display(RInducedModule(MakeSpecht(H,5,2,1),0));
0*S()
gap&gt; Display(RInducedModule(MakeSpecht(H,5,2,1),1));
S(6,2,1)+S(5,3,1)+S(5,2,1^2)
gap&gt; Display(RInducedModule(MakeSpecht(H,5,2,1),2));
0*S()
gap&gt; Display(RInducedModule(MakeSpecht(H,5,2,1),3));
S(5,2^2)
</Example>

The function <Ref Oper="EResidueDiagram"/>, prints the diagram
of <M>\mu</M>, labeling each node with its <M>e</M>-residue. A quick check of
this diagram confirms the answers above.

<Example>
gap&gt; EResidueDiagram(H,5,2,1);
  0  1  2  3  0
  3  0
  2
true
</Example>

<E><Q>Quantized</Q> induction</E><P/>

When <Ref Oper="RInducedModule"/> is applied to the canonical basis elements
<C>MakeFockPIM(</C><M>\mu</M><C>)</C> (or more generally elements of the Fock
space; see <Ref Oper="Specht"/>), a <Q>quantum analogue</Q> of induction is
applied. More precisely, the function
<C>InducedModule(</C><M>*,i</M><C>)</C> corresponds to the action of the
generator <M>F_i</M> of the quantum group <M>U_q(\widehat{sl_e})</M> on
<M>\mathcal{F}</M> <Cite Key="LLT"/>.

<Example>
gap&gt; H:=Specht(3);; x:=RInducedModule(MakeFockPIM(H,4,2),1,2);;
gap&gt; Display(x); Display(MakePIM(x));
Sq(6,2)+vSq(4^2)+v^2Sq(4,2^2)
Pq(6,2)
</Example>

See also <Ref Oper="SInducedModule"/>, <Ref Oper="RRestrictedModule"/> and
<Ref Oper="SRestrictedModule"/>. This function requires the package &specht;
(see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="SInducedModule" Arg="x, s"/>
<Meth Name="SInducedModule" Label="for residues"
  Arg="x, s, r"/>
<Description>
The function <Ref Oper="SInducedModule"/>, standing for <Q>string
induction</Q>, provides a more efficient way of <M>r</M>-inducing <M>s</M>
times (and a way of inducing <M>s</M> times if the residue <M>r</M> is
omitted); <M>r</M>-induction is explained in "<Ref Oper="RInducedModule"/>.

<Example>
gap&gt; H:=Specht(4);; Display(SInducedModule(MakePIM(H,5,2,1),3));
P(8,2,1) + 3P(7,3,1) + 2P(7,2^2) + 6P(6,3,2) + 6P(6,3,1^2) + 3P(6,2,1^3) + 2P(5,3^2) + P(5,2^2,1^2)
gap&gt; Display(SInducedModule(MakePIM(H,5,2,1),3,1));
P(6,3,1^2)
gap&gt; Display(RInducedModule(MakePIM(H,5,2,1),1,1,1));
6P(6,3,1^2)
</Example>

Note that the multiplicity of each summand of
<C>RInducedModule(</C><M>x,r,\ldots,r</M><C>)</C>
is divisible by <M>s!</M> and that <Ref Oper="SInducedModule"/> divides by
this constant.<P/>

As with <Ref Oper="RInducedModule"/> this function can also be applied to
elements of the Fock space (see <Ref Oper="Specht"/>), in which case the
quantum analogue of induction is used.<P/>

See also <Ref Oper="RInducedModule"/>. This function requires the
package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="RRestrictedModule" Arg="x"/>
<Meth Name="RRestrictedModule" Label="for residues"
  Arg="x r1[, r2, ...]"/>
<Returns>the corresponding module for <M>H(S_{n-1})</M> when given a module
<M>x</M> for <M>H(S_n)</M></Returns>
<Description>
The restriction of the Specht module <M>S(\mu)</M> is the linear combination
of Specht modules <M>\sum S(\nu)</M> where <M>\nu</M> runs over the
partitions whose diagrams are obtained by deleting a node from the diagram of
<M>\mu</M>. If only nodes of residue <M>r</M> are deleted then this
corresponds to first restricting <M>S(\mu)</M> and then taking one of the
block components of the restriction; this process
is known as <E><M>r</M>-restriction</E> (cf. <M>r</M>-induction in
<Ref Oper="RInducedModule"/>).<P/>

There is also a function <Ref Oper="SRestrictedModule"/> which provides a
faster way of <M>r</M>-restricting <M>s</M> times (and restricting
<M>s</M> times).<P/>

When more than one residue if given to <Ref Oper="RRestrictedModule"/> it
returns <C>RRestrictedModule(</C><M>x,r_1,r_2,\ldots,r_k</M><C>)</C>=
  <C>RRestrictedModule(
    RRestrictedModule(</C><M>x,r_1</M><C>)</C><M>,r_2,\ldots,r_k</M><C>)</C>
(cf. <Ref Oper="RInducedModule"/>).

<Example>
gap&gt; H:=Specht(6);; Display(RRestrictedModule(MakePIM(H,5,3,2,1),4));
2P(4,3,2,1)
gap&gt; Display(RRestrictedModule(MakeSimple(H,5,3,2),1));
D(5,2^2)
</Example>

<E><Q>Quantized</Q> restriction</E><P/>

As with <Ref Oper="RInducedModule"/>, when <Ref Oper="RRestrictedModule"/> is
applied to the canonical basis elements <C>MakeFockPIM(</C><M>\mu</M><C>)</C>
a quantum analogue of restriction is applied; this time,
<C>RestrictedModule(</C><M>*,i</M><C>)</C> corresponds to the action
of the generator <M>E_i</M> of <M>U_q(\widehat{sl_e})</M> on <M>\mathcalF</M>
<Cite Key="LLT"/>.<P/>

See also <Ref Oper="RInducedModule"/>, <Ref Oper="SInducedModule"/> and
<Ref Oper="SRestrictedModule"/>. This function requires the package &specht;
(see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="SRestrictedModule" Arg="x, s"/>
<Meth Name="SRestrictedModule" Label="for residues"
  Arg="x, s, r"/>
<Description>
As with <Ref Oper="SInducedModule"/> this function provides a more efficient way of
<M>r</M>-restricting <M>s</M> times, or restricting <M>s</M> times if the
residue <M>r</M> is omitted (cf. <Ref Oper="SInducedModule"/>).


<Example>
gap&gt; H:=Specht(6);; Display(SRestrictedModule(MakeSpecht(H,4,3,2),3));
3S(4,2) + 2S(4,1^2) + 3S(3^2) + 6S(3,2,1) + 2S(2^3)
gap&gt; Display(SRestrictedModule(MakePIM(H,5,4,1),2,4));
P(4^2)
</Example>

See also <Ref Oper="RInducedModule"/>, <Ref Oper="SInducedModule"/> and
<Ref Oper="RRestrictedModule"/>. This function requires the package &specht;
(see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
</Section>
<!--######################################################################-->
<Section>
<Heading>Semi-standard and standard tableaux</Heading>
These functions are not really part of &Specht; proper; however they are
related and may well be of use to someone. Tableaux are represented
by objects, that can be constructed from a list of lists.
<!--######################################################################-->
<ManSection>
<Meth Name="Tableau" Arg="tab"/>
<Returns>tableau object corresponding to the given list of lists</Returns>
<Description>
This is the constructor for tableau objects. The first entry of the given
argument list is the list corresponding to the first row of the tableau.
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="SemiStandardTableaux" Arg="mu, nu"/>
<Returns>list of the semistandard <M>\mu</M>-tableaux of type <M>\nu</M>
<Cite Key="JK"/></Returns>
<Description>
<M>\mu</M> a partition, <M>\nu</M> a composition.
<Example>
gap&gt; SizeScreen([80,20]);; Display(SemiStandardTableaux([4,3],[1,1,1,2,2]));
[ Tableau( [ [ 1, 2, 3, 4 ], [ 4, 5, 5 ] ] ), Tableau( [ [ 1, 2, 3, 5 ], [ 4, 4, 5 ] ] ),
  Tableau( [ [ 1, 2, 4, 4 ], [ 3, 5, 5 ] ] ), Tableau( [ [ 1, 2, 4, 5 ], [ 3, 4, 5 ] ] ),
  Tableau( [ [ 1, 3, 4, 4 ], [ 2, 5, 5 ] ] ), Tableau( [ [ 1, 3, 4, 5 ], [ 2, 4, 5 ] ] ) ]
</Example>
See also <Ref Oper="StandardTableaux"/>. This function requires the package
&specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="StandardTableaux" Arg="mu"/>
<Returns>list of the standard <M>\mu</M>-tableaux</Returns>
<Description>
<M>\mu</M> a partition
<Example>
gap&gt; SizeScreen([80,20]);; Display(StandardTableaux(4,2));
[ Tableau( [ [ 1, 2, 3, 4 ], [ 5, 6 ] ] ), Tableau( [ [ 1, 2, 3, 5 ], [ 4, 6 ] ] ),
  Tableau( [ [ 1, 2, 3, 6 ], [ 4, 5 ] ] ), Tableau( [ [ 1, 2, 4, 5 ], [ 3, 6 ] ] ),
  Tableau( [ [ 1, 2, 4, 6 ], [ 3, 5 ] ] ), Tableau( [ [ 1, 2, 5, 6 ], [ 3, 4 ] ] ),
  Tableau( [ [ 1, 3, 4, 5 ], [ 2, 6 ] ] ), Tableau( [ [ 1, 3, 4, 6 ], [ 2, 5 ] ] ),
  Tableau( [ [ 1, 3, 5, 6 ], [ 2, 4 ] ] ) ]
</Example>
See also <Ref Oper="SemiStandardTableaux"/>. This function requires the package
&specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="ConjugatTableau" Arg="tab"/>
<Returns>tableau obtained from <M>tab</M> by interchangings its rows and
columns</Returns>
<Description>
<Example>
gap&gt; Display(ConjugateTableau(Tableau([ [ 1, 3, 5, 6 ], [ 2, 4 ] ])));
Standard Tableau:
1	2
3	4
5
6
</Example>
This function requires the package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="ShapeTableau" Arg="tab"/>
<Returns>the partition (or composition) obtained from <M>tab</M></Returns>
<Description>
<Example>
gap&gt; ShapeTableau( Tableau([ [ 1, 1, 2, 3 ], [ 4, 5 ] ]) );
[ 4, 2 ]
</Example>
This function requires the package &specht; (see <Ref Func="LoadPackage" BookName="Reference"/>).
</Description>
</ManSection>
<!--######################################################################-->
<ManSection>
<Meth Name="TypeTableau" Arg="tab"/>
<Returns>the type of the (semistandard) tableau <M>tab</M></Returns>
<Description>
The type of a tableau is, the composition <M>\sigma=
(\sigma_1,\sigma_2,\ldots)</M> where <M>\sigma_i</M> is
the number of entries in <M>tab</M> which are equal to <M>i</M>.
<Example>
gap&gt; List(SemiStandardTableaux([5,4,2],[4,3,0,1,3]),TypeTableau);
[ [ 4, 3, 0, 1, 3 ], [ 4, 3, 0, 1, 3 ], [ 4, 3, 0, 1, 3 ], [ 4, 3, 0, 1, 3 ], [ 4, 3, 0, 1, 3 ] ]
</Example>
This function requires the package &specht; (see <Ref Func="LoadPackage" BookName="Reference" BookName="Reference"/>).
</Description>
</ManSection>
</Section>
</Chapter>

